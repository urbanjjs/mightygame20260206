<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>ÎßàÏù¥Ìã∞ - ÌÖåÏä§Ìä∏ Î≤ÑÏ†Ñ</title>
<style>
/* ===== Í∏∞Î≥∏ Ïä§ÌÉÄÏùº ===== */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: linear-gradient(135deg, #1a472a 0%, #2d5a3d 100%);
    min-height: 100vh;
    color: #fff;
}

#app {
    max-width: 1100px;
    margin: 0 auto;
    padding: 10px;
    padding-right: 320px;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
}

/* ===== ÏÉÅÎã® Ï†ïÎ≥¥ Î∞î ===== */
#info-bar {
    background: rgba(0, 0, 0, 0.5);
    padding: 10px 20px;
    border-radius: 10px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px;
}

.game-info {
    display: flex;
    gap: 20px;
    flex-wrap: wrap;
}

.game-info span {
    background: rgba(255, 255, 255, 0.1);
    padding: 5px 12px;
    border-radius: 5px;
    font-size: 14px;
}

.controls {
    display: flex;
    gap: 10px;
}

.controls button {
    padding: 8px 15px;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-size: 14px;
    transition: all 0.2s;
}

#test-mode-toggle {
    background: #4CAF50;
    color: white;
}

#test-mode-toggle.active {
    background: #4CAF50;
}

#test-mode-toggle:not(.active) {
    background: #666;
}

#settings-btn {
    background: #2196F3;
    color: white;
}

.controls button:hover {
    transform: scale(1.05);
}

/* ===== Î©îÏù∏ Í≤åÏûÑ ÏòÅÏó≠ ===== */
#game-area {
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: 10px;
}

/* ===== ÌîåÎ†àÏù¥Ïñ¥ ÏòÅÏó≠ ===== */
.player-area {
    background: rgba(0, 0, 0, 0.3);
    border-radius: 10px;
    padding: 10px;
    transition: all 0.3s;
}

.player-area.active-turn {
    box-shadow: 0 0 20px rgba(255, 215, 0, 0.7);
    border: 2px solid gold;
}

.player-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 8px;
    padding-bottom: 5px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.2);
}

.player-name {
    font-weight: bold;
    font-size: 16px;
}

.player-role {
    font-size: 12px;
    padding: 2px 8px;
    border-radius: 3px;
}

.player-role.master {
    background: #FFD700;
    color: #000;
}

.player-role.friend {
    background: #FF69B4;
    color: #000;
}

.player-role.opposition {
    background: #666;
    color: #fff;
}

.player-hand {
    display: flex;
    flex-wrap: nowrap;
    min-height: 70px;
    justify-content: center;
    padding-left: 15px;
}

.player-hand .card {
    margin-left: -30px;
}

.player-hand .card:first-child {
    margin-left: 0;
}

.player-hand .card:hover {
    z-index: 10;
}

.player-hand .card.playable:hover {
    transform: translateY(-15px);
    z-index: 20;
}

.player-score {
    margin-top: 8px;
    font-size: 14px;
    text-align: center;
}

.top-row {
    display: flex;
    justify-content: center;
    gap: 20px;
}

.player-area.top-left,
.player-area.top-right {
    width: 280px;
}

.player-area.top-left .player-hand .card,
.player-area.top-right .player-hand .card {
    margin-left: -25px;
}

.player-area.top-left .player-hand .card:first-child,
.player-area.top-right .player-hand .card:first-child {
    margin-left: 0;
}

.middle-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    flex: 1;
}

.player-area.left,
.player-area.right {
    width: 280px;
    padding: 10px;
}

.player-area.left .player-hand,
.player-area.right .player-hand {
    min-height: 70px;
    padding-left: 15px;
}

.player-area.left .player-hand .card,
.player-area.right .player-hand .card {
    margin-left: -25px;
}

.player-area.left .player-hand .card:first-child,
.player-area.right .player-hand .card:first-child {
    margin-left: 0;
}

.player-area.left .player-score,
.player-area.right .player-score {
    margin-top: 8px;
    font-size: 12px;
}

.bottom-row {
    display: flex;
    justify-content: center;
    gap: 20px;
}

.player-area.bottom-left {
    width: 250px;
}

.player-area.user {
    width: 750px;
    padding: 5px 10px;
}

.player-area.user .player-hand {
    min-height: 90px;
    padding-left: 10px;
}

.player-area.user .player-hand .card {
    margin-left: 0;
}

.player-area.user .player-hand .card:first-child {
    margin-left: 0;
}

/* ===== Ïπ¥Îìú Ïä§ÌÉÄÏùº ===== */
.card {
    width: 60px;
    height: 84px;
    border-radius: 4px;
    cursor: default;
    transition: all 0.2s;
    position: relative;
    box-shadow: none;
    overflow: hidden;
    background-color: transparent;
    border: none;
}

.card.face-up {
    background-size: contain;
    background-repeat: no-repeat;
    background-position: center;
}

.card.face-down {
    background-image: url('https://deckofcardsapi.com/static/img/back.png');
    background-size: cover;
    background-position: center;
}

.card .card-image {
    width: 100%;
    height: 100%;
    object-fit: contain;
    border-radius: 3px;
    border: none;
}

.card.joker {
    background-color: transparent;
}

.card.joker .joker-image {
    width: 100%;
    height: 100%;
    object-fit: contain;
    border-radius: 4px;
}

.card.highlighted {
    box-shadow: 0 0 10px 3px rgba(76, 175, 80, 0.8);
    border-color: #4CAF50;
}

.card.dimmed {
    opacity: 0.5;
}

.card.selected {
    transform: translateY(-15px);
    box-shadow: 0 5px 20px rgba(0, 0, 0, 0.5);
    border-color: #FFD700;
}

.card.playable {
    cursor: pointer;
}

.card.playable:hover {
    transform: translateY(-10px);
}

.player-area.user .card {
    width: 65px;
    height: 91px;
}

.player-area.user .player-header {
    margin-bottom: 4px;
    padding-bottom: 3px;
}

.player-area.user .player-score {
    margin-top: 4px;
}

.card .special-label {
    position: absolute;
    top: -10px;
    right: -10px;
    background: linear-gradient(135deg, #FFD700 0%, #FFA000 100%);
    color: #000;
    font-size: 9px;
    padding: 3px 6px;
    border-radius: 4px;
    font-weight: bold;
    box-shadow: 1px 1px 3px rgba(0,0,0,0.3);
    z-index: 10;
}

/* ===== Ìä∏Î¶≠ ÏòÅÏó≠ ===== */
#trick-area {
    flex: 1;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
}

.trick-cards {
    position: relative;
    width: 320px;
    height: 220px;
}

.trick-card {
    position: absolute;
    width: 60px;
    height: 84px;
    transition: all 0.3s ease;
}

.trick-card[data-player="0"] { bottom: 0; left: 50%; transform: translateX(-50%); }
.trick-card[data-player="1"] { top: 50%; left: 0; transform: translateY(-50%); }
.trick-card[data-player="2"] { top: 0; left: 70px; }
.trick-card[data-player="3"] { top: 0; right: 70px; }
.trick-card[data-player="4"] { top: 50%; right: 0; transform: translateY(-50%); }

.trick-card .card {
    width: 100%;
    height: 100%;
}

.trick-card.winner .card {
    box-shadow: 0 0 20px rgba(255, 215, 0, 0.9);
    border-color: #ffd700;
}

#trick-info {
    margin-top: 10px;
    text-align: center;
    font-size: 14px;
    background: rgba(0, 0, 0, 0.3);
    padding: 5px 15px;
    border-radius: 5px;
}

/* ===== Ïï°ÏÖò ÏòÅÏó≠ ===== */
#action-area {
    background: rgba(0, 0, 0, 0.5);
    padding: 15px;
    border-radius: 10px;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    gap: 10px;
    min-height: 60px;
}

#action-message {
    color: #FFD700;
    font-size: 16px;
    font-weight: bold;
    text-align: center;
}

#action-buttons {
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
    justify-content: center;
}

#action-buttons button {
    padding: 10px 25px;
    font-size: 16px;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    transition: all 0.2s;
}

#action-buttons button.primary {
    background: #4CAF50;
    color: white;
}

#action-buttons button.secondary {
    background: #666;
    color: white;
}

#action-buttons button:disabled {
    background: #444;
    cursor: not-allowed;
    opacity: 0.5;
}

#action-buttons button:not(:disabled):hover {
    transform: scale(1.05);
}

#timer {
    font-size: 18px;
    font-weight: bold;
    color: #FFD700;
}

/* ===== AI Î°úÍ∑∏ Ìå®ÎÑê ===== */
#ai-log-panel {
    position: fixed;
    top: 60px;
    right: 10px;
    width: 300px;
    max-height: calc(100vh - 80px);
    background: rgba(0, 0, 0, 0.85);
    border-radius: 10px;
    z-index: 100;
    display: flex;
    flex-direction: column;
}

#ai-log-panel .panel-header {
    padding: 8px 12px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    cursor: pointer;
    border-bottom: 1px solid #444;
    background: rgba(0, 0, 0, 0.5);
    border-radius: 10px 10px 0 0;
    flex-shrink: 0;
}

#ai-log-panel .panel-header span {
    font-size: 14px;
    font-weight: bold;
}

#ai-log-panel .panel-header button {
    background: none;
    border: none;
    color: white;
    cursor: pointer;
    font-size: 14px;
    padding: 2px 6px;
}

#ai-log-panel .panel-content {
    flex: 1;
    overflow-y: auto;
    padding: 12px;
    max-height: 500px;
}

#ai-log-panel.collapsed {
    max-height: none;
}

#ai-log-panel.collapsed .panel-content {
    display: none;
}

.log-entry {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 5px;
    padding: 8px 10px;
    margin-bottom: 8px;
    font-size: 16px;
}

.log-entry .log-header {
    font-weight: bold;
    margin-bottom: 4px;
    color: #FFD700;
    font-size: 18px;
}

.log-entry .log-reasons {
    color: #bbb;
    padding-left: 8px;
    line-height: 1.4;
    font-size: 14px;
}

.log-entry .reason-line {
    margin: 3px 0;
}

/* ===== Î™®Îã¨ Ïä§ÌÉÄÏùº ===== */
.modal {
    position: fixed;
    top: 50%;
    left: calc(50% - 140px);
    transform: translate(-50%, -50%);
    background: #2d2d2d;
    border-radius: 12px;
    padding: 20px;
    z-index: 1000;
    min-width: 350px;
    box-shadow: 0 10px 50px rgba(0, 0, 0, 0.5);
}

.modal.hidden {
    display: none;
}

.modal h3 {
    margin-bottom: 15px;
    text-align: center;
    font-size: 20px;
}

.modal p {
    margin-bottom: 12px;
    text-align: center;
    color: #ccc;
    font-size: 14px;
}

#modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.7);
    z-index: 999;
}

#modal-overlay.hidden {
    display: none;
}

/* ÎπÑÎî© Î™®Îã¨ */
#bidding-modal {
    min-width: 320px;
    max-width: 400px;
    padding: 15px 20px;
    top: 30%;
}

#bidding-modal h3 {
    font-size: 18px;
    margin-bottom: 12px;
}

.current-bid {
    text-align: center;
    margin-bottom: 12px;
    font-size: 14px;
    color: #FFD700;
    padding: 6px;
    background: rgba(255, 215, 0, 0.1);
    border-radius: 5px;
}

.bid-controls {
    margin-bottom: 12px;
}

.bid-controls label {
    display: block;
    margin-bottom: 5px;
    font-weight: bold;
    font-size: 13px;
}

.bid-number, .bid-suit {
    margin-bottom: 10px;
}

.number-buttons,
.suit-buttons {
    display: flex;
    gap: 4px;
    flex-wrap: wrap;
    justify-content: center;
}

.number-buttons button,
.suit-buttons button {
    padding: 6px 10px;
    font-size: 13px;
    border: 2px solid #444;
    background: #333;
    color: white;
    border-radius: 4px;
    cursor: pointer;
    transition: all 0.2s;
    min-width: 32px;
}

.number-buttons button:hover,
.suit-buttons button:hover {
    background: #444;
}

.number-buttons button.selected,
.suit-buttons button.selected {
    background: #4CAF50;
    border-color: #4CAF50;
}

.number-buttons button:disabled,
.suit-buttons button:disabled {
    opacity: 0.3;
    cursor: not-allowed;
}

.suit-buttons button {
    font-size: 20px;
    width: 40px;
    height: 40px;
    padding: 0;
}

.suit-buttons button.red {
    color: #d32f2f;
}

.bid-preview {
    text-align: center;
    font-size: 16px;
    margin-bottom: 12px;
    color: #4CAF50;
    padding: 6px;
    background: rgba(76, 175, 80, 0.1);
    border-radius: 5px;
}

.bid-actions {
    display: flex;
    gap: 10px;
    justify-content: center;
}

.bid-actions button {
    padding: 8px 20px;
    font-size: 14px;
    border: none;
    border-radius: 5px;
    cursor: pointer;
}

#bid-submit {
    background: #4CAF50;
    color: white;
}

#bid-submit:disabled {
    background: #444;
    cursor: not-allowed;
}

#bid-pass {
    background: #f44336;
    color: white;
}

/* ÏπúÍµ¨ ÏÑ†Ïñ∏ Î™®Îã¨ */
.quick-friend-selection {
    display: flex;
    gap: 15px;
    justify-content: center;
    margin-bottom: 20px;
}

.quick-friend-btn {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px;
    padding: 15px 25px;
    border: 3px solid #444;
    border-radius: 12px;
    cursor: pointer;
    transition: all 0.2s;
    min-width: 140px;
}

.quick-friend-btn:hover {
    transform: scale(1.05);
}

.quick-friend-btn .btn-icon {
    font-size: 32px;
}

.quick-friend-btn .btn-text {
    font-size: 14px;
    font-weight: bold;
}

.quick-friend-btn .btn-card {
    font-size: 20px;
    font-weight: bold;
    padding: 5px 10px;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 5px;
}

.quick-friend-btn .btn-card.red {
    color: #d32f2f;
}

.mighty-btn {
    background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%);
    color: #000;
    border-color: #FFD700;
}

.mighty-btn:hover {
    box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
}

.joker-btn {
    background: linear-gradient(135deg, #9c27b0 0%, #e91e63 100%);
    color: white;
    border-color: #9c27b0;
}

.joker-btn:hover {
    box-shadow: 0 0 20px rgba(156, 39, 176, 0.5);
}

.manual-selection {
    margin-bottom: 20px;
    background: rgba(0, 0, 0, 0.2);
    border-radius: 8px;
    padding: 10px;
}

.manual-selection summary {
    cursor: pointer;
    padding: 10px;
    text-align: center;
    color: #aaa;
    font-size: 14px;
}

.manual-selection summary:hover {
    color: #fff;
}

.manual-selection[open] summary {
    margin-bottom: 15px;
    border-bottom: 1px solid #444;
}

.manual-confirm-btn {
    display: block;
    margin: 15px auto 0;
    padding: 10px 25px;
    background: #4CAF50;
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-size: 14px;
}

.manual-confirm-btn:hover {
    background: #45a049;
}

.friend-selection {
    margin-bottom: 15px;
}

.suit-select,
.rank-select {
    margin-bottom: 15px;
}

.rank-select .rank-buttons {
    display: flex;
    gap: 5px;
    flex-wrap: wrap;
    justify-content: center;
}

#friend-rank-buttons {
    display: flex;
    gap: 5px;
    flex-wrap: wrap;
    justify-content: center;
}

#friend-rank-buttons button {
    padding: 8px 12px;
    font-size: 14px;
    border: 2px solid #444;
    background: #333;
    color: white;
    border-radius: 5px;
    cursor: pointer;
}

#friend-rank-buttons button.selected {
    background: #4CAF50;
    border-color: #4CAF50;
}

#friend-suit-buttons {
    display: flex;
    gap: 15px;
    justify-content: center;
}

.friend-preview {
    text-align: center;
    font-size: 16px;
    margin-bottom: 10px;
    color: #4CAF50;
}

.friend-actions {
    display: flex;
    gap: 15px;
    justify-content: center;
    margin-top: 15px;
}

.friend-actions button {
    padding: 12px 25px;
    font-size: 16px;
    border: none;
    border-radius: 5px;
    cursor: pointer;
}

#friend-confirm {
    background: #4CAF50;
    color: white;
}

#no-friend {
    background: #FF9800;
    color: white;
}

/* Ïπ¥Îìú ÍµêÌôò Î™®Îã¨ */
#exchange-modal {
    min-width: 600px;
}

.exchange-hand {
    display: flex;
    gap: 5px;
    flex-wrap: wrap;
    justify-content: center;
    margin-bottom: 20px;
}

.exchange-hand .card {
    cursor: pointer;
}

.exchange-hand .card.selected {
    border-color: #f44336;
    transform: translateY(-10px);
}

.exchange-info {
    text-align: center;
    margin-bottom: 15px;
    font-size: 16px;
}

.giruda-change-section {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 8px;
    padding: 12px 15px;
    margin-bottom: 15px;
}

.giruda-change-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 8px;
    font-weight: bold;
    font-size: 14px;
}

.giruda-change-cost {
    color: #ff9800;
    font-size: 13px;
}

.giruda-change-current {
    text-align: center;
    margin-bottom: 10px;
    font-size: 13px;
    color: #ccc;
}

.giruda-change-current .current-giruda {
    color: #4CAF50;
    font-weight: bold;
}

.giruda-change-current .current-bid {
    color: #2196F3;
    font-weight: bold;
}

.giruda-change-buttons {
    display: flex;
    justify-content: center;
    gap: 8px;
    flex-wrap: wrap;
}

.giruda-btn {
    padding: 8px 16px;
    font-size: 16px;
    border: 2px solid #555;
    border-radius: 5px;
    cursor: pointer;
    background: rgba(0, 0, 0, 0.3);
    color: white;
    transition: all 0.2s;
}

.giruda-btn:hover {
    background: rgba(255, 255, 255, 0.1);
}

.giruda-btn.selected {
    border-color: #4CAF50;
    background: rgba(76, 175, 80, 0.3);
}

.giruda-btn.current {
    border-color: #2196F3;
    background: rgba(33, 150, 243, 0.2);
}

.giruda-btn.red {
    color: #e53935;
}

.giruda-btn.black {
    color: #fff;
}

.giruda-btn:disabled {
    opacity: 0.4;
    cursor: not-allowed;
}

.giruda-btn.no-giruda {
    color: #9e9e9e;
    font-weight: bold;
    font-size: 14px;
}

.giruda-separator {
    color: #555;
    margin: 0 5px;
    align-self: center;
}

.solino-option {
    display: flex;
    align-items: center;
    gap: 5px;
    cursor: pointer;
    font-size: 13px;
    padding: 5px 10px;
    background: rgba(255, 152, 0, 0.2);
    border-radius: 5px;
    border: 1px solid #ff9800;
}

.solino-option:hover {
    background: rgba(255, 152, 0, 0.3);
}

.solino-option input[type="checkbox"] {
    width: 16px;
    height: 16px;
    cursor: pointer;
}

#exchange-confirm {
    display: block;
    margin: 0 auto;
    padding: 12px 40px;
    font-size: 16px;
    background: #4CAF50;
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
}

#exchange-confirm:disabled {
    background: #444;
    cursor: not-allowed;
}

/* Ï°∞Ïª§ ÏàòÌä∏ ÏÑ†Ïñ∏ Î™®Îã¨ */
#joker-suit-buttons {
    display: flex;
    gap: 15px;
    justify-content: center;
}

#joker-suit-buttons button {
    width: 70px;
    height: 70px;
    font-size: 36px;
    border: 3px solid #444;
    background: #333;
    border-radius: 10px;
    cursor: pointer;
    transition: all 0.2s;
}

#joker-suit-buttons button:hover {
    transform: scale(1.1);
    border-color: #4CAF50;
}

#joker-suit-buttons button.red {
    color: #d32f2f;
}

/* Í≤åÏûÑ Í≤∞Í≥º Î™®Îã¨ */
#result-modal {
    min-width: 500px;
}

#result-title {
    font-size: 28px;
}

#result-title.win {
    color: #4CAF50;
}

#result-title.lose {
    color: #f44336;
}

#result-content {
    margin-bottom: 25px;
}

.result-summary {
    text-align: center;
    margin-bottom: 20px;
    font-size: 18px;
}

.result-scores {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 10px;
    padding: 15px;
}

.result-header {
    display: flex;
    justify-content: space-between;
    padding: 8px 0;
    border-bottom: 2px solid rgba(255, 255, 255, 0.3);
    font-weight: bold;
    font-size: 13px;
    color: #aaa;
}

.result-header span:first-child {
    flex: 1;
}

.result-header span:nth-child(2),
.result-header span:nth-child(3) {
    width: 60px;
    text-align: right;
}

.score-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 8px 0;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}

.score-row:last-child {
    border-bottom: none;
}

.score-row .player-name {
    font-weight: bold;
    flex: 1;
}

.score-row .earned-points {
    width: 60px;
    text-align: right;
    color: #FFD700;
    font-weight: bold;
}

.score-row .score-change {
    width: 60px;
    text-align: right;
    font-weight: bold;
}

.score-row .score-change.positive {
    color: #4CAF50;
}

.score-row .score-change.negative {
    color: #f44336;
}

.friend-contribution {
    margin-top: 15px;
    padding: 12px;
    background: rgba(255, 215, 0, 0.1);
    border-radius: 8px;
    border: 1px solid rgba(255, 215, 0, 0.3);
}

.contribution-header {
    font-size: 14px;
    font-weight: bold;
    color: #FFD700;
    margin-bottom: 10px;
    text-align: center;
}

.contribution-details {
    display: flex;
    flex-direction: column;
    gap: 6px;
}

.contribution-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 4px 8px;
    background: rgba(0, 0, 0, 0.2);
    border-radius: 4px;
}

.contribution-label {
    color: #aaa;
    font-size: 13px;
}

.contribution-value {
    font-weight: bold;
    color: #fff;
    font-size: 14px;
}

.contribution-value.special {
    color: #FF9800;
}

/* Í≤åÏûÑ Í∏∞Î°ù ÌÖåÏù¥Î∏î */
.game-history {
    margin-top: 20px;
    padding-top: 15px;
    border-top: 1px solid rgba(255, 255, 255, 0.2);
}

.history-header {
    font-size: 14px;
    font-weight: bold;
    color: #FFD700;
    margin-bottom: 10px;
    text-align: center;
}

.history-table-wrapper {
    max-height: 200px;
    overflow-y: auto;
    border-radius: 5px;
    background: rgba(0, 0, 0, 0.2);
}

.history-table {
    width: 100%;
    border-collapse: collapse;
    font-size: 12px;
}

.history-table th,
.history-table td {
    padding: 6px 4px;
    text-align: center;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}

.history-table th {
    background: rgba(0, 0, 0, 0.3);
    color: #aaa;
    font-weight: normal;
    position: sticky;
    top: 0;
}

.history-table tbody tr:hover {
    background: rgba(255, 255, 255, 0.05);
}

.history-table td.positive {
    color: #4CAF50;
}

.history-table td.negative {
    color: #f44336;
}

.history-table td.gov-win {
    color: #4CAF50;
    font-weight: bold;
}

.history-table td.opp-win {
    color: #2196F3;
    font-weight: bold;
}

.history-table tfoot {
    background: rgba(0, 0, 0, 0.3);
}

.history-table tfoot td {
    padding: 8px 4px;
    border-top: 2px solid rgba(255, 255, 255, 0.2);
}

.history-legend {
    display: flex;
    justify-content: center;
    gap: 15px;
    margin-top: 8px;
    font-size: 11px;
    color: #888;
}

.history-legend span {
    display: flex;
    align-items: center;
    gap: 3px;
}

.result-buttons {
    display: flex;
    justify-content: center;
    gap: 15px;
    margin-top: 20px;
}

#new-game-btn {
    padding: 12px 40px;
    font-size: 16px;
    background: #4CAF50;
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
}

#new-game-btn:hover {
    background: #45a049;
}

#end-game-btn {
    padding: 12px 40px;
    font-size: 16px;
    background: #666;
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
}

#end-game-btn:hover {
    background: #555;
}

/* ÏÑ§Ï†ï Î™®Îã¨ */
.settings-content {
    margin-bottom: 20px;
}

.setting-group {
    margin-bottom: 20px;
}

.setting-group h4 {
    margin-bottom: 10px;
    padding-bottom: 5px;
    border-bottom: 1px solid #444;
}

.setting-group label {
    display: block;
    margin: 10px 0;
    cursor: pointer;
}

.setting-group select {
    padding: 5px 10px;
    font-size: 14px;
    margin-left: 10px;
}

.setting-hint {
    display: block;
    font-size: 11px;
    color: #888;
    margin-left: 22px;
    margin-top: 3px;
}

#settings-close {
    display: block;
    margin: 0 auto;
    padding: 10px 30px;
    font-size: 16px;
    background: #666;
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
}

/* ===== ÌåÄÎ≥Ñ Ï†êÏàò ÏßÑÌñâ Î∞î ===== */
.score-progress {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-top: 5px;
    padding: 5px 10px;
    background: rgba(0, 0, 0, 0.3);
    border-radius: 5px;
}

.score-bar {
    flex: 1;
    height: 12px;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 6px;
    overflow: hidden;
    position: relative;
}

.score-bar-fill {
    height: 100%;
    border-radius: 6px;
    transition: width 0.5s ease;
}

.score-bar-fill.government {
    background: linear-gradient(90deg, #4CAF50, #8BC34A);
}

.score-bar-fill.opposition {
    background: linear-gradient(90deg, #2196F3, #03A9F4);
}

.score-label {
    font-size: 12px;
    min-width: 80px;
}

.score-label.government { color: #4CAF50; }
.score-label.opposition { color: #2196F3; }

/* ===== Ïú†Ìã∏Î¶¨Ìã∞ ===== */
.hidden {
    display: none !important;
}

/* ===== Ïï†ÎãàÎ©îÏù¥ÏÖò ===== */
@keyframes pulse {
    0% { box-shadow: 0 0 10px rgba(255, 215, 0, 0.5); }
    50% { box-shadow: 0 0 25px rgba(255, 215, 0, 0.8); }
    100% { box-shadow: 0 0 10px rgba(255, 215, 0, 0.5); }
}

.player-area.active-turn {
    animation: pulse 1.5s infinite;
}

@keyframes cardDeal {
    from {
        opacity: 0;
        transform: translateY(-50px) rotate(-10deg);
    }
    to {
        opacity: 1;
        transform: translateY(0) rotate(0);
    }
}

.card.dealing {
    animation: cardDeal 0.3s ease-out forwards;
}

@keyframes cardPlay {
    0% { opacity: 0; transform: scale(0.5); }
    50% { opacity: 0.8; transform: scale(1.1); }
    100% { opacity: 1; transform: scale(1); }
}

.trick-card .card {
    animation: cardPlay 0.4s ease-out;
}

@keyframes winnerGlow {
    0% { box-shadow: 0 0 10px rgba(255, 215, 0, 0.5); }
    50% { box-shadow: 0 0 30px rgba(255, 215, 0, 1); }
    100% { box-shadow: 0 0 10px rgba(255, 215, 0, 0.5); }
}

.trick-card.winner .card {
    animation: winnerGlow 1s infinite;
}

@keyframes scoreChange {
    0% { transform: scale(1); }
    50% { transform: scale(1.3); color: #FFD700; }
    100% { transform: scale(1); }
}

.player-score.changed {
    animation: scoreChange 0.5s ease;
}

/* ===== Î∞òÏùëÌòï ===== */
@media (max-width: 1400px) {
    #app {
        padding-right: 280px;
    }
    #ai-log-panel {
        width: 260px;
    }
    .log-entry {
        font-size: 14px;
        padding: 6px 8px;
    }
    .log-entry .log-header {
        font-size: 16px;
    }
    .log-entry .log-reasons {
        font-size: 12px;
    }
}

@media (max-width: 1200px) {
    #app {
        padding-right: 10px;
    }
    #ai-log-panel {
        top: auto;
        bottom: 0;
        right: 10px;
        width: 300px;
        max-height: 200px;
        border-radius: 10px 10px 0 0;
    }
    .log-entry {
        font-size: 14px;
        padding: 6px 8px;
    }
    .log-entry .log-header {
        font-size: 16px;
    }
    .log-entry .log-reasons {
        font-size: 12px;
    }
    .player-area.top-left,
    .player-area.top-right {
        width: 220px;
    }
    .player-area.left,
    .player-area.right {
        width: 220px;
    }
    .player-area.user {
        width: 550px;
        padding: 5px 10px;
    }
    .player-area.user .card {
        width: 55px;
        height: 77px;
    }
    .player-hand .card {
        margin-left: -25px;
    }
    .player-area.left .player-hand .card,
    .player-area.right .player-hand .card {
        margin-left: -25px;
    }
    .player-area.user .player-hand .card {
        margin-left: 0;
    }
    .modal {
        left: 50%;
    }
}

@media (max-width: 900px) {
    .game-info {
        gap: 10px;
    }
    .game-info span {
        font-size: 12px;
        padding: 3px 8px;
    }
    .player-area.left,
    .player-area.right {
        width: 160px;
    }
    .card {
        width: 45px;
        height: 63px;
    }
    .player-area.user .card {
        width: 50px;
        height: 70px;
    }
    .player-hand .card {
        margin-left: -22px;
    }
    .player-area.left .player-hand .card,
    .player-area.right .player-hand .card {
        margin-left: -22px;
    }
    .player-area.user .player-hand .card {
        margin-left: 0;
    }
    .player-area.top-left,
    .player-area.top-right {
        width: 160px;
    }
    .player-area.user {
        width: 400px;
        padding: 4px 8px;
    }
    .trick-cards {
        width: 260px;
        height: 180px;
    }
    .trick-card {
        width: 55px;
        height: 77px;
    }
    .trick-card[data-player="2"] { left: 60px; }
    .trick-card[data-player="3"] { right: 60px; }
    #ai-log-panel {
        width: 260px;
    }
    .log-entry {
        font-size: 12px;
        padding: 5px 6px;
    }
    .log-entry .log-header {
        font-size: 14px;
    }
    .log-entry .log-reasons {
        font-size: 11px;
    }
    #bidding-modal {
        min-width: 280px;
        max-width: 320px;
    }
}
</style>
</head>
<body>
    <div id="app">
        <header id="info-bar">
            <div class="game-info">
                <span id="round-info">ÎùºÏö¥Îìú: -/10</span>
                <span id="contract-info">Í≥µÏïΩ: -</span>
                <span id="giruda-info">Í∏∞Î£®Îã§: -</span>
                <span id="mighty-info">ÎßàÏù¥Ìã∞: -</span>
                <span id="joker-call-info">Ï°∞Ïª§ÏΩú: -</span>
                <span id="friend-card-info">ÏπúÍµ¨: ?</span>
            </div>
            <div class="controls">
                <button id="test-mode-toggle" class="active">üîß ÌÖåÏä§Ìä∏Î™®Îìú ON</button>
                <button id="settings-btn">‚öôÔ∏è ÏÑ§Ï†ï</button>
            </div>
        </header>

        <main id="game-area">
            <div class="top-row">
                <div id="player-2" class="player-area top-left">
                    <div class="player-header">
                        <span class="player-name">AI-2</span>
                        <span class="player-role"></span>
                    </div>
                    <div class="player-hand"></div>
                    <div class="player-score">Ï†êÏàò: <span>0</span>Ï†ê</div>
                </div>
                <div id="player-3" class="player-area top-right">
                    <div class="player-header">
                        <span class="player-name">AI-3</span>
                        <span class="player-role"></span>
                    </div>
                    <div class="player-hand"></div>
                    <div class="player-score">Ï†êÏàò: <span>0</span>Ï†ê</div>
                </div>
            </div>

            <div class="middle-row">
                <div id="player-1" class="player-area left">
                    <div class="player-header">
                        <span class="player-name">AI-1</span>
                        <span class="player-role"></span>
                    </div>
                    <div class="player-hand"></div>
                    <div class="player-score">Ï†êÏàò: <span>0</span>Ï†ê</div>
                </div>

                <div id="trick-area">
                    <div class="trick-cards">
                        <div class="trick-card" data-player="2"></div>
                        <div class="trick-card" data-player="1"></div>
                        <div class="trick-card" data-player="3"></div>
                        <div class="trick-card" data-player="4"></div>
                        <div class="trick-card" data-player="0"></div>
                    </div>
                    <div id="trick-info"></div>
                </div>

                <div id="player-4" class="player-area right">
                    <div class="player-header">
                        <span class="player-name">AI-4</span>
                        <span class="player-role"></span>
                    </div>
                    <div class="player-hand"></div>
                    <div class="player-score">Ï†êÏàò: <span>0</span>Ï†ê</div>
                </div>
            </div>

            <div class="bottom-row">
                <div id="player-0" class="player-area user">
                    <div class="player-header">
                        <span class="player-name">ÎÇò</span>
                        <span class="player-role"></span>
                    </div>
                    <div class="player-hand"></div>
                    <div class="player-score">Ï†êÏàò: <span>0</span>Ï†ê</div>
                </div>
            </div>
        </main>

        <div id="action-area">
            <div id="action-message"></div>
            <div id="action-buttons"></div>
            <div id="timer"></div>
        </div>

        <div id="ai-log-panel">
            <div class="panel-header">
                <span>AI ÏùòÏÇ¨Í≤∞Ï†ï Î°úÍ∑∏</span>
                <button id="log-toggle">‚ñº</button>
            </div>
            <div class="panel-content" id="ai-log-content"></div>
        </div>

        <div id="modal-overlay" class="hidden">
            <div id="modal-content"></div>
        </div>

        <div id="bidding-modal" class="modal hidden">
            <h3>ÎπÑÎî©</h3>
            <div class="current-bid">ÌòÑÏû¨ ÏµúÍ≥† ÎπÑÎî©: <span id="current-bid-display">ÏóÜÏùå</span></div>
            <div class="bid-controls">
                <div class="bid-number">
                    <label>Ïà´Ïûê:</label>
                    <div class="number-buttons" id="bid-numbers"></div>
                </div>
                <div class="bid-suit">
                    <label>Í∏∞Î£®Îã§:</label>
                    <div class="suit-buttons" id="bid-suits"></div>
                </div>
            </div>
            <div class="bid-preview">ÎÇòÏùò ÎπÑÎî©: <span id="bid-preview">-</span></div>
            <div class="bid-actions">
                <button id="bid-submit" disabled>ÎπÑÎî©ÌïòÍ∏∞</button>
                <button id="bid-pass">Ìå®Ïä§</button>
            </div>
        </div>

        <div id="friend-modal" class="modal hidden">
            <h3>ÏπúÍµ¨ ÏÑ†Ïñ∏</h3>
            <p>ÏπúÍµ¨Î°ú ÏßÄÏ†ïÌï† Ïπ¥ÎìúÎ•º ÏÑ†ÌÉùÌïòÏÑ∏Ïöî.</p>
            <div class="quick-friend-selection">
                <button id="friend-mighty" class="quick-friend-btn mighty-btn">
                    <span class="btn-icon">üëë</span>
                    <span class="btn-text">ÎßàÏù¥Ìã∞ ÏπúÍµ¨</span>
                    <span class="btn-card" id="mighty-card-display">‚ô†A</span>
                </button>
                <button id="friend-joker" class="quick-friend-btn joker-btn">
                    <span class="btn-icon">üÉè</span>
                    <span class="btn-text">Ï°∞Ïª§ ÏπúÍµ¨</span>
                    <span class="btn-card">JOKER</span>
                </button>
            </div>
            <details class="manual-selection">
                <summary>ÏßÅÏ†ë Ïπ¥Îìú ÏÑ†ÌÉù</summary>
                <div class="friend-selection">
                    <div class="suit-select">
                        <label>ÏàòÌä∏:</label>
                        <div id="friend-suit-buttons"></div>
                    </div>
                    <div class="rank-select">
                        <label>Ïà´Ïûê:</label>
                        <div id="friend-rank-buttons"></div>
                    </div>
                </div>
                <div class="friend-preview">ÏÑ†ÌÉùÌïú Ïπ¥Îìú: <span id="friend-preview">-</span></div>
                <button id="friend-confirm" class="manual-confirm-btn">ÏÑ†ÌÉù ÏôÑÎ£å</button>
            </details>
            <div class="friend-actions">
                <button id="no-friend">ÎÖ∏ÌîÑÎ†åÎìú</button>
            </div>
        </div>

        <div id="exchange-modal" class="modal hidden">
            <h3>Ïπ¥Îìú ÍµêÌôò</h3>
            <p>Î∞îÎã•Ïóê Î≤ÑÎ¶¥ Ïπ¥Îìú 3Ïû•ÏùÑ ÏÑ†ÌÉùÌïòÏÑ∏Ïöî.</p>
            <div class="exchange-hand" id="exchange-hand"></div>
            <div class="exchange-info">ÏÑ†ÌÉù: <span id="exchange-count">0</span>/3</div>
            <div class="giruda-change-section" id="giruda-change-section">
                <div class="giruda-change-header">
                    <span>Í∏∞Î£®Îã§ Î≥ÄÍ≤Ω</span>
                    <span class="giruda-change-cost" id="giruda-change-cost"></span>
                </div>
                <div class="giruda-change-current" id="giruda-current-info"></div>
                <div class="giruda-change-buttons" id="giruda-change-buttons"></div>
            </div>
            <button id="exchange-confirm" disabled>ÌôïÏù∏</button>
        </div>

        <div id="joker-call-modal" class="modal hidden">
            <h3>Ï°∞Ïª§ ÏàòÌä∏ ÏÑ†Ïñ∏</h3>
            <p>ÏÉÅÎåÄÎ∞©Ïù¥ ÎÇ¥Ïïº Ìï† ÏàòÌä∏Î•º ÏÑ†ÌÉùÌïòÏÑ∏Ïöî.</p>
            <div id="joker-suit-buttons"></div>
        </div>

        <div id="result-modal" class="modal hidden">
            <h3 id="result-title">Í≤åÏûÑ Í≤∞Í≥º</h3>
            <div id="result-content"></div>
            <div class="result-buttons">
                <button id="new-game-btn">Îã§Ïãú ÌïòÍ∏∞</button>
                <button id="end-game-btn">ÎÅùÎÇ¥Í∏∞</button>
            </div>
        </div>

        <div id="settings-modal" class="modal hidden">
            <h3>ÏÑ§Ï†ï</h3>
            <div class="settings-content">
                <div class="setting-group">
                    <h4>ÌÖåÏä§Ìä∏ Î™®Îìú</h4>
                    <label>
                        <input type="checkbox" id="setting-show-ai-cards" checked>
                        AI Ïπ¥Îìú Í≥µÍ∞ú
                    </label>
                    <label>
                        <input type="checkbox" id="setting-show-ai-log" checked>
                        AI ÏùòÏÇ¨Í≤∞Ï†ï Î°úÍ∑∏
                    </label>
                    <label>
                        <input type="checkbox" id="setting-highlight-playable" checked>
                        ÎÇº Ïàò ÏûàÎäî Ïπ¥Îìú ÌëúÏãú
                    </label>
                </div>
                <div class="setting-group">
                    <h4>AI ÏÑ§Ï†ï</h4>
                    <label>
                        AI ÏÜçÎèÑ:
                        <select id="setting-ai-speed">
                            <option value="2000">ÎäêÎ¶º (2Ï¥à)</option>
                            <option value="1000" selected>Î≥¥ÌÜµ (1Ï¥à)</option>
                            <option value="300">Îπ†Î¶Ñ (0.3Ï¥à)</option>
                            <option value="0">Ï¶âÏãú</option>
                        </select>
                    </label>
                </div>
                <div class="setting-group">
                    <h4>Í≤åÏûÑ Í∑úÏπô</h4>
                    <label>
                        <input type="checkbox" id="setting-use-sayeon" checked>
                        ÏÇ¨Ïó∞(ÂõõÁÑ∂) Í∏∞Îä•
                        <span class="setting-hint">Ï£ºÍ≥µÏù¥ Ï≤´ Ïπ¥Îìú Ï†ÑÏóê ÏπúÍµ¨Ïùò Ï°∞Ïª§ Î≥¥Ïú† Ïó¨Î∂Ä ÌôïÏù∏</span>
                    </label>
                </div>
            </div>
            <button id="settings-close">Îã´Í∏∞</button>
        </div>
    </div>

<script>
// ========================================
// ===== constants.js =====
// ========================================

const SUITS = {
    SPADE: 'spade',
    DIAMOND: 'diamond',
    HEART: 'heart',
    CLUB: 'club'
};

const SUIT_SYMBOLS = {
    [SUITS.SPADE]: '‚ô†',
    [SUITS.DIAMOND]: '‚óÜ',
    [SUITS.HEART]: '‚ô•',
    [SUITS.CLUB]: '‚ô£'
};

const SUIT_NAMES = {
    [SUITS.SPADE]: 'Ïä§ÌéòÏù¥Îìú',
    [SUITS.DIAMOND]: 'Îã§Ïù¥ÏïÑ',
    [SUITS.HEART]: 'ÌïòÌä∏',
    [SUITS.CLUB]: 'ÌÅ¥Î°úÎ≤Ñ'
};

const SUIT_STRENGTH = {
    [SUITS.SPADE]: 4,
    [SUITS.DIAMOND]: 3,
    [SUITS.HEART]: 2,
    [SUITS.CLUB]: 1,
    'none': 0
};

const RANKS = ['A', 'K', 'Q', 'J', '10', '9', '8', '7', '6', '5', '4', '3', '2'];

const RANK_VALUES = {
    'A': 14, 'K': 13, 'Q': 12, 'J': 11, '10': 10,
    '9': 9, '8': 8, '7': 7, '6': 6, '5': 5, '4': 4, '3': 3, '2': 2
};

const POINT_RANKS = ['A', 'K', 'Q', 'J', '10'];

const PHASES = {
    WAITING: 'waiting',
    DEALING: 'dealing',
    DEAL_CHECK: 'dealCheck',
    BIDDING: 'bidding',
    EXCHANGING: 'exchanging',
    FRIEND_DECLARATION: 'friendDeclaration',
    PLAYING: 'playing',
    TRICK_END: 'trickEnd',
    GAME_END: 'gameEnd'
};

const ROLES = {
    MASTER: 'master',
    FRIEND: 'friend',
    OPPOSITION: 'opposition',
    UNKNOWN: 'unknown'
};

const GAME_CONFIG = {
    PLAYER_COUNT: 5,
    CARDS_PER_PLAYER: 10,
    FLOOR_CARDS: 3,
    TOTAL_ROUNDS: 10,
    MIN_BID: 13,
    MAX_BID: 20,
    TOTAL_POINTS: 20
};

const DEFAULT_SETTINGS = {
    showAICards: true,
    showAILog: true,
    highlightPlayable: true,
    aiSpeed: 1000,
    useSayeon: true
};

const CARD_IMAGE_BASE = 'https://deckofcardsapi.com/static/img/';

const CARD_IMAGE_CODES = {
    'spade_A': 'AS', 'spade_2': '2S', 'spade_3': '3S', 'spade_4': '4S', 'spade_5': '5S',
    'spade_6': '6S', 'spade_7': '7S', 'spade_8': '8S', 'spade_9': '9S', 'spade_10': '0S',
    'spade_J': 'JS', 'spade_Q': 'QS', 'spade_K': 'KS',
    'diamond_A': 'AD', 'diamond_2': '2D', 'diamond_3': '3D', 'diamond_4': '4D', 'diamond_5': '5D',
    'diamond_6': '6D', 'diamond_7': '7D', 'diamond_8': '8D', 'diamond_9': '9D', 'diamond_10': '0D',
    'diamond_J': 'JD', 'diamond_Q': 'QD', 'diamond_K': 'KD',
    'heart_A': 'AH', 'heart_2': '2H', 'heart_3': '3H', 'heart_4': '4H', 'heart_5': '5H',
    'heart_6': '6H', 'heart_7': '7H', 'heart_8': '8H', 'heart_9': '9H', 'heart_10': '0H',
    'heart_J': 'JH', 'heart_Q': 'QH', 'heart_K': 'KH',
    'club_A': 'AC', 'club_2': '2C', 'club_3': '3C', 'club_4': '4C', 'club_5': '5C',
    'club_6': '6C', 'club_7': '7C', 'club_8': '8C', 'club_9': '9C', 'club_10': '0C',
    'club_J': 'JC', 'club_Q': 'QC', 'club_K': 'KC'
};

function getCardImageUrl(suit, rank) {
    const key = `${suit}_${rank}`;
    const code = CARD_IMAGE_CODES[key];
    if (code) return `${CARD_IMAGE_BASE}${code}.png`;
    return null;
}

const CARD_BACK_IMAGE = 'https://deckofcardsapi.com/static/img/back.png';
const JOKER_IMAGE = 'https://deckofcardsapi.com/static/img/X1.png';

// ========================================
// ===== EventBus (Ïã†Í∑ú) =====
// ========================================

class EventBus {
    constructor() {
        this.listeners = new Map();
    }
    on(event, callback) {
        if (!this.listeners.has(event)) this.listeners.set(event, []);
        this.listeners.get(event).push(callback);
        return () => {
            const cbs = this.listeners.get(event);
            const idx = cbs.indexOf(callback);
            if (idx > -1) cbs.splice(idx, 1);
        };
    }
    emit(event, data) {
        const cbs = this.listeners.get(event) || [];
        for (const cb of cbs) cb(data);
    }
    once(event, callback) {
        const unsub = this.on(event, (data) => { callback(data); unsub(); });
    }
}

const eventBus = new EventBus();

// ========================================
// ===== card.js =====
// ========================================

class Card {
    constructor(suit, rank) {
        this.suit = suit;
        this.rank = rank;
        this.isJoker = false;
    }

    static createJoker() {
        const card = new Card(null, 'JOKER');
        card.isJoker = true;
        return card;
    }

    equals(other) {
        if (!other) return false;
        if (this.isJoker && other.isJoker) return true;
        return this.suit === other.suit && this.rank === other.rank;
    }

    toString() {
        if (this.isJoker) return 'JOKER';
        return `${SUIT_SYMBOLS[this.suit]}${this.rank}`;
    }

    isPointCard() {
        if (this.isJoker) return false;
        return POINT_RANKS.includes(this.rank);
    }

    isRed() {
        return this.suit === SUITS.DIAMOND || this.suit === SUITS.HEART;
    }

    getBaseStrength() {
        if (this.isJoker) return 0;
        return RANK_VALUES[this.rank];
    }

    getDealmeeScore(mighty) {
        if (this.isJoker) return -1;
        if (this.equals(mighty)) return 0;
        if (this.rank === '10') return 0.5;
        if (POINT_RANKS.includes(this.rank) && this.rank !== '10') return 1;
        return 0;
    }
}

class Deck {
    constructor() {
        this.cards = [];
        this.initialize();
    }

    initialize() {
        this.cards = [];
        for (const suit of Object.values(SUITS)) {
            for (const rank of RANKS) {
                this.cards.push(new Card(suit, rank));
            }
        }
        this.cards.push(Card.createJoker());
    }

    shuffle() {
        for (let i = this.cards.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [this.cards[i], this.cards[j]] = [this.cards[j], this.cards[i]];
        }
    }

    deal(count) {
        return this.cards.splice(0, count);
    }
}

// ===== Ïú†Ìã∏Î¶¨Ìã∞ Ìï®Ïàò =====

function getMighty(giruda) {
    if (giruda === SUITS.SPADE) return new Card(SUITS.DIAMOND, 'A');
    return new Card(SUITS.SPADE, 'A');
}

function getJokerCall(giruda) {
    if (giruda === SUITS.CLUB) return new Card(SUITS.SPADE, '3');
    return new Card(SUITS.CLUB, '3');
}

function sortCards(cards, giruda = null, mighty = null) {
    const redSuits = [SUITS.DIAMOND, SUITS.HEART];
    const blackSuits = [SUITS.SPADE, SUITS.CLUB];
    let suitOrder;
    if (giruda) {
        const isGirudaRed = redSuits.includes(giruda);
        if (isGirudaRed) {
            const otherRed = redSuits.find(s => s !== giruda);
            suitOrder = [giruda, SUITS.SPADE, otherRed, SUITS.CLUB];
        } else {
            const otherBlack = blackSuits.find(s => s !== giruda);
            suitOrder = [giruda, SUITS.DIAMOND, otherBlack, SUITS.HEART];
        }
    } else {
        suitOrder = [SUITS.SPADE, SUITS.DIAMOND, SUITS.CLUB, SUITS.HEART];
    }
    return [...cards].sort((a, b) => {
        const aIsMighty = mighty && a.equals(mighty);
        const bIsMighty = mighty && b.equals(mighty);
        if (aIsMighty && !bIsMighty) return -1;
        if (!aIsMighty && bIsMighty) return 1;
        if (a.isJoker && !b.isJoker) return -1;
        if (!a.isJoker && b.isJoker) return 1;
        if (a.isJoker && b.isJoker) return 0;
        const suitDiff = suitOrder.indexOf(a.suit) - suitOrder.indexOf(b.suit);
        if (suitDiff !== 0) return suitDiff;
        return RANK_VALUES[b.rank] - RANK_VALUES[a.rank];
    });
}

function findCard(hand, card) {
    return hand.find(c => c.equals(card));
}

function hasCard(hand, card) {
    return hand.some(c => c.equals(card));
}

function getCardsOfSuit(hand, suit) {
    return hand.filter(c => !c.isJoker && c.suit === suit);
}

function countPoints(cards) {
    return cards.filter(c => c.isPointCard()).length;
}

function calculateDealmeeScore(hand, mighty) {
    return hand.reduce((sum, card) => sum + card.getDealmeeScore(mighty), 0);
}

function checkPoolRequestEligibility(hand, mighty) {
    const hasMighty = hand.some(c => c.equals(mighty));
    const hasJoker = hand.some(c => c.isJoker);
    const pointCardCount = hand.filter(c => {
        if (c.isJoker) return false;
        if (c.equals(mighty)) return false;
        return POINT_RANKS.includes(c.rank);
    }).length;
    if (hasMighty && pointCardCount === 0) {
        return { eligible: true, reason: 'ÎßàÏù¥Ìã∞ Î≥¥Ïú†, Ï†êÏàòÏπ¥Îìú ÏóÜÏùå', hasMighty: true, hasJoker: false, pointCardCount: 0 };
    }
    if (hasJoker && pointCardCount <= 1) {
        return { eligible: true, reason: pointCardCount === 0 ? 'Ï°∞Ïª§ Î≥¥Ïú†, Ï†êÏàòÏπ¥Îìú ÏóÜÏùå' : 'Ï°∞Ïª§ Î≥¥Ïú†, Ï†êÏàòÏπ¥Îìú 1Ïû•', hasMighty: false, hasJoker: true, pointCardCount };
    }
    return { eligible: false, reason: null, hasMighty, hasJoker, pointCardCount };
}

function getPlayableCards(hand, leadSuit, round, gameContext) {
    if (!leadSuit) return [...hand];
    const { mighty, jokerCalled, mightyPlayedInTrick } = gameContext;
    const joker = hand.find(c => c.isJoker);
    const mightyCard = findCard(hand, mighty);
    if (jokerCalled) {
        if (joker) {
            if (mightyCard) return [joker, mightyCard];
            return [joker];
        }
    }
    const leadSuitCards = getCardsOfSuit(hand, leadSuit);
    if (leadSuitCards.length > 0) {
        const playableCards = [...leadSuitCards];
        if (mightyCard && !leadSuitCards.some(c => c.equals(mighty))) {
            playableCards.push(mightyCard);
        }
        if (joker && round >= 2 && round <= 9 && !mightyPlayedInTrick) {
            playableCards.push(joker);
        }
        return playableCards;
    }
    if (mightyPlayedInTrick) return hand.filter(c => !c.isJoker);
    return [...hand];
}

// ========================================
// ===== player.js =====
// ========================================

class Player {
    constructor(index, name, isHuman = false) {
        this.index = index;
        this.name = name;
        this.isHuman = isHuman;
        this.hand = [];
        this.scoreCards = [];
        this.role = ROLES.UNKNOWN;
        this.totalScore = 0;
        this.hasPassed = false;
    }

    reset() {
        this.hand = [];
        this.scoreCards = [];
        this.role = ROLES.UNKNOWN;
        this.hasPassed = false;
    }

    receiveCards(cards) { this.hand.push(...cards); }

    sortHand(giruda = null, mighty = null) {
        this.hand = sortCards(this.hand, giruda, mighty);
    }

    playCard(card) {
        const index = this.hand.findIndex(c => c.equals(card));
        if (index !== -1) return this.hand.splice(index, 1)[0];
        return null;
    }

    addScoreCards(cards) {
        const points = cards.filter(c => c.isPointCard());
        this.scoreCards.push(...points);
    }

    getScore() { return this.scoreCards.length; }
    hasCard(card) { return hasCard(this.hand, card); }
    hasSuit(suit) { return this.hand.some(c => !c.isJoker && c.suit === suit); }
    setRole(role) { this.role = role; }

    getRoleText() {
        switch (this.role) {
            case ROLES.MASTER: return 'Ï£ºÍ≥µ';
            case ROLES.FRIEND: return 'ÏπúÍµ¨';
            case ROLES.OPPOSITION: return 'ÏïºÎãπ';
            default: return '';
        }
    }
}
</script>
<script>
// ========================================
// ===== gameState.js =====
// ========================================

class GameState {
    constructor() {
        this.reset();
    }

    reset() {
        if (this.players && this.players.length === 5) {
            const savedScores = this.players.map(p => p.totalScore);
            this.players.forEach((p, i) => {
                p.reset();
                p.totalScore = savedScores[i];
            });
        } else {
            this.players = [
                new Player(0, 'ÎÇò', true),
                new Player(1, 'AI-1', false),
                new Player(2, 'AI-2', false),
                new Player(3, 'AI-3', false),
                new Player(4, 'AI-4', false)
            ];
        }

        this.phase = PHASES.WAITING;
        this.round = 0;
        this.dealer = Math.floor(Math.random() * 5);
        this.currentTurn = 0;

        this.bidding = {
            currentBid: null,
            history: [],
            passedPlayers: []
        };

        this.contract = {
            master: null,
            friend: null,
            friendCard: null,
            bidValue: 0,
            giruda: null,
            mighty: null,
            jokerCall: null,
            isNoFriend: false,
            isNoGiruda: false,
            isSolino: false,
            friendRevealed: false
        };

        this.trick = {
            cards: [],
            leadPlayer: null,
            leadSuit: null,
            jokerCalled: false,
            jokerCallSuit: null
        };

        this.floorCards = [];
        this.governmentScore = 0;
        this.oppositionScore = 0;
        this.mightyUsed = false;
        this.jokerUsed = false;
        this.friendRevealed = false;
        this.playedCards = [];
        this.playerVoidSuits = new Map();
        this.cardTracker = this.initializeCardTracker();
        this.aiLogs = [];
        this.dealmeePool = 0;
        this.poolRequester = null;
        this.sayeonResponse = null;

        this.friendContribution = {
            tricksWon: 0,
            pointsSecured: 0,
            mightyUsed: false,
            jokerUsed: false
        };
    }

    getNextPlayer(current) {
        return (current + 1) % GAME_CONFIG.PLAYER_COUNT;
    }

    getFirstBidder() {
        return this.getNextPlayer(this.dealer);
    }

    isValidBid(value, suit) {
        if (value < GAME_CONFIG.MIN_BID || value > GAME_CONFIG.MAX_BID) return false;
        if (!this.bidding.currentBid) return true;
        const currentValue = this.bidding.currentBid.value;
        const currentSuit = this.bidding.currentBid.suit;
        if (value > currentValue) return true;
        if (value === currentValue) {
            return SUIT_STRENGTH[suit] > SUIT_STRENGTH[currentSuit];
        }
        return false;
    }

    recordBid(playerIndex, value, suit) {
        this.bidding.currentBid = { player: playerIndex, value, suit };
        this.bidding.history.push({ player: playerIndex, value, suit, type: 'bid' });
    }

    recordPass(playerIndex) {
        this.bidding.passedPlayers.push(playerIndex);
        this.bidding.history.push({ player: playerIndex, type: 'pass' });
        this.players[playerIndex].hasPassed = true;
    }

    isBiddingComplete() {
        if (this.bidding.passedPlayers.length === GAME_CONFIG.PLAYER_COUNT) return true;
        const activeBidders = [];
        for (let i = 0; i < GAME_CONFIG.PLAYER_COUNT; i++) {
            if (!this.bidding.passedPlayers.includes(i)) activeBidders.push(i);
        }
        return activeBidders.length === 1 && this.bidding.currentBid !== null;
    }

    determineMaster() {
        if (this.bidding.currentBid) return this.bidding.currentBid.player;
        return null;
    }

    // ‚òÖ Í∞úÏÑ†: ÎÖ∏Í∏∞Î£®Îã§ Ïãú girudaÎ•º nullÎ°ú ÌÜµÏùº
    setupContract() {
        const master = this.determineMaster();
        if (master === null) return false;

        this.contract.master = master;
        this.contract.bidValue = this.bidding.currentBid.value;

        const bidSuit = this.bidding.currentBid.suit;
        this.contract.isNoGiruda = (bidSuit === 'none');
        this.contract.giruda = this.contract.isNoGiruda ? null : bidSuit;

        this.contract.mighty = getMighty(this.contract.giruda);
        this.contract.jokerCall = getJokerCall(this.contract.giruda);
        this.players[master].setRole(ROLES.MASTER);
        return true;
    }

    // ‚òÖ Í∞úÏÑ†: ÏπúÍµ¨ Ïπ¥ÎìúÍ∞Ä Î∞îÎã•Ïóê ÏûàÎäî Í≤ΩÏö∞ Ï≤òÎ¶¨
    setFriend(friendCard) {
        this.contract.friendCard = friendCard;

        if (this.contract.isSolino) {
            this.contract.isNoFriend = true;
            this.contract.friendCard = null;
            this.players.forEach((player, idx) => {
                if (idx !== this.contract.master) player.setRole(ROLES.OPPOSITION);
            });
            return;
        }

        if (!friendCard) {
            this.contract.isNoFriend = true;
            this.players.forEach((player, idx) => {
                if (idx !== this.contract.master) player.setRole(ROLES.OPPOSITION);
            });
            return;
        }

        // Ï£ºÍ≥µÏù¥ ÏπúÍµ¨ Ïπ¥ÎìúÎ•º Í∞ÄÏßÑ Í≤ΩÏö∞
        if (this.players[this.contract.master].hasCard(friendCard)) {
            this.contract.isNoFriend = true;
            this.contract.friend = null;
        }
        // ‚òÖ Î∞îÎã•Ïóê Î≤ÑÎ†§ÏßÑ Í≤ΩÏö∞ÎèÑ ÎÖ∏ÌîÑÎ†åÎìú
        else if (this.floorCards.some(c => c.equals(friendCard))) {
            this.contract.isNoFriend = true;
            this.contract.friend = null;
        } else {
            // ÏπúÍµ¨ Ïπ¥Îìú ÏÜåÏú†Ïûê Ï∞æÍ∏∞
            for (let i = 0; i < GAME_CONFIG.PLAYER_COUNT; i++) {
                if (i === this.contract.master) continue;
                if (this.players[i].hasCard(friendCard)) {
                    this.contract.friend = i;
                    this.players[i].setRole(ROLES.FRIEND);
                    break;
                }
            }
        }

        // ÎÇòÎ®∏ÏßÄÎäî ÏïºÎãπ
        this.players.forEach((player, idx) => {
            if (player.role === ROLES.UNKNOWN) player.setRole(ROLES.OPPOSITION);
        });
    }

    revealFriend(playerIndex) {
        if (!this.friendRevealed && this.contract.friend === playerIndex) {
            this.friendRevealed = true;
            this.contract.friendRevealed = true;
            return true;
        }
        return false;
    }

    startTrick(leadPlayer) {
        this.trick = {
            cards: [],
            leadPlayer,
            leadSuit: null,
            jokerCalled: false,
            jokerCallSuit: null
        };
        this.currentTurn = leadPlayer;
    }

    playCardToTrick(playerIndex, card, jokerCallSuit = null) {
        this.trick.cards.push({ player: playerIndex, card });

        if (this.trick.cards.length === 1) {
            if (card.isJoker) {
                this.trick.leadSuit = jokerCallSuit;
                this.trick.jokerCallSuit = jokerCallSuit;
            } else {
                this.trick.leadSuit = card.suit;
            }
            if (card.equals(this.contract.jokerCall) && this.round > 1 && this.round < 10) {
                this.trick.jokerCalled = true;
            }
        }

        if (card.equals(this.contract.mighty)) this.mightyUsed = true;
        if (card.isJoker) this.jokerUsed = true;

        if (this.contract.friendCard && card.equals(this.contract.friendCard)) {
            this.revealFriend(playerIndex);
        }

        this.playedCards.push(card);

        if (!card.isJoker && card.suit !== this.trick.leadSuit) {
            if (!this.playerVoidSuits.has(playerIndex)) {
                this.playerVoidSuits.set(playerIndex, new Set());
            }
            this.playerVoidSuits.get(playerIndex).add(this.trick.leadSuit);
        }

        this.updateCardTracker(playerIndex, card, this.trick.leadSuit);
        this.currentTurn = this.getNextPlayer(playerIndex);
    }

    determineTrickWinner() {
        const { mighty, giruda } = this.contract;
        const leadSuit = this.trick.leadSuit;
        const round = this.round;
        const isNoGiruda = this.contract.isNoGiruda;

        let winner = null;
        let winningCard = null;
        let highestValue = -1;

        for (const play of this.trick.cards) {
            const card = play.card;
            let priority = 0;
            let cardValue = 0;

            if (card.equals(mighty)) {
                priority = 1000;
                cardValue = 100;
            } else if (card.isJoker && round >= 2 && round <= 9 && !this.trick.jokerCalled) {
                priority = 900;
                cardValue = 90;
            } else if (card.isJoker) {
                priority = 0;
                cardValue = 0;
            } else if (!isNoGiruda && giruda && card.suit === giruda) {
                priority = 500;
                cardValue = RANK_VALUES[card.rank];
            } else if (card.suit === leadSuit) {
                priority = 100;
                cardValue = RANK_VALUES[card.rank];
            } else {
                priority = 0;
                cardValue = 0;
            }

            const totalValue = priority + cardValue;
            if (totalValue > highestValue) {
                highestValue = totalValue;
                winner = play.player;
                winningCard = card;
            }
        }

        return { winner, winningCard };
    }

    endTrick() {
        const { winner, winningCard } = this.determineTrickWinner();
        const trickCards = this.trick.cards.map(p => p.card);
        const trickPoints = trickCards.filter(c => c.isPointCard()).length;

        if (winner === this.contract.friend) {
            this.friendContribution.tricksWon++;
            this.friendContribution.pointsSecured += trickPoints;
            if (winningCard) {
                if (winningCard.equals(this.contract.mighty)) this.friendContribution.mightyUsed = true;
                if (winningCard.isJoker) this.friendContribution.jokerUsed = true;
            }
        }

        this.players[winner].addScoreCards(trickCards);
        this.updateTeamScores();
        return winner;
    }

    updateTeamScores() {
        this.governmentScore = 0;
        this.oppositionScore = 0;
        for (const player of this.players) {
            const score = player.getScore();
            if (player.role === ROLES.MASTER || player.role === ROLES.FRIEND) {
                this.governmentScore += score;
            } else {
                this.oppositionScore += score;
            }
        }
    }

    isGovernmentWinning() {
        return this.governmentScore >= this.contract.bidValue;
    }

    isBackrun() {
        return this.oppositionScore === GAME_CONFIG.TOTAL_POINTS;
    }

    calculateFinalScores() {
        const bidValue = this.contract.bidValue;
        const govScore = this.governmentScore;
        const multiplier = this.contract.isNoGiruda ? 2 : 1;
        let results = [];

        if (this.isBackrun()) {
            const penalty = 20 * multiplier;
            for (const player of this.players) {
                if (player.role === ROLES.MASTER) {
                    results.push({ player: player.index, change: -penalty * 2 });
                } else if (player.role === ROLES.FRIEND) {
                    results.push({ player: player.index, change: -penalty });
                } else {
                    results.push({ player: player.index, change: penalty });
                }
            }
            return { winner: 'opposition', isBackrun: true, results };
        }

        const govWins = govScore >= bidValue;
        let baseScore;
        if (govWins) {
            baseScore = (govScore - 10) * multiplier;
        } else {
            baseScore = (bidValue - govScore) * multiplier;
        }

        if (this.contract.isNoFriend) {
            for (const player of this.players) {
                if (player.role === ROLES.MASTER) {
                    results.push({ player: player.index, change: govWins ? baseScore * 4 : -baseScore * 4 });
                } else {
                    results.push({ player: player.index, change: govWins ? -baseScore : baseScore });
                }
            }
        } else {
            for (const player of this.players) {
                if (player.role === ROLES.MASTER) {
                    results.push({ player: player.index, change: govWins ? baseScore * 2 : -baseScore * 2 });
                } else if (player.role === ROLES.FRIEND) {
                    results.push({ player: player.index, change: govWins ? baseScore : -baseScore });
                } else {
                    results.push({ player: player.index, change: govWins ? -baseScore : baseScore });
                }
            }
        }

        if (this.dealmeePool > 0 && govWins) {
            const masterResult = results.find(r => r.player === this.contract.master);
            if (masterResult) masterResult.change += this.dealmeePool;
        }

        return { winner: govWins ? 'government' : 'opposition', isBackrun: false, results };
    }

    addAILog(log) {
        this.aiLogs.push(log);
        if (this.aiLogs.length > 50) this.aiLogs.shift();
    }

    getTeamContext(playerIndex) {
        const player = this.players[playerIndex];
        return {
            myRole: player.role,
            isFriendRevealed: this.friendRevealed,
            masterIndex: this.contract.master,
            friendIndex: this.contract.friend,
            governmentPlayers: this.players
                .filter(p => p.role === ROLES.MASTER || p.role === ROLES.FRIEND)
                .map(p => p.index),
            oppositionPlayers: this.players
                .filter(p => p.role === ROLES.OPPOSITION)
                .map(p => p.index)
        };
    }

    // ‚òÖ Í∞úÏÑ†: analyzeTrick - cardsToWin Î∞è remainingPlayers Í≥ÑÏÇ∞ ÏàòÏ†ï
    analyzeTrick(playerIndex) {
        const player = this.players[playerIndex];
        const hand = player.hand;
        const teamContext = this.getTeamContext(playerIndex);

        const mightyPlayedInTrick = this.trick.cards.some(
            p => p.card.equals(this.contract.mighty)
        );

        const playableCards = getPlayableCards(hand, this.trick.leadSuit, this.round, {
            mighty: this.contract.mighty,
            jokerCalled: this.trick.jokerCalled,
            mightyPlayedInTrick
        });

        let currentWinner = null;
        let isGovernmentWinning = false;
        let isOppositionWinning = false;
        let isUncertain = false;

        if (this.trick.cards.length > 0) {
            const { winner } = this.determineTrickWinner();
            currentWinner = winner;
            if (teamContext.governmentPlayers.includes(winner)) {
                isGovernmentWinning = true;
            } else if (teamContext.oppositionPlayers.includes(winner)) {
                isOppositionWinning = true;
            } else {
                isUncertain = true;
            }
        }

        // ‚òÖ Í∞úÏÑ†Îêú cardsToWin Í≥ÑÏÇ∞
        const cardsToWin = playableCards.filter(card => {
            if (this.trick.cards.length === 0) return true;
            if (card.equals(this.contract.mighty)) return true;
            if (card.isJoker && this.round >= 2 && this.round <= 9 && !this.trick.jokerCalled) {
                return !mightyPlayedInTrick;
            }
            if (card.isJoker) return false;

            const { winningCard } = this.determineTrickWinner();
            if (!winningCard) return true;
            if (winningCard.equals(this.contract.mighty)) return false;
            if (winningCard.isJoker && !this.trick.jokerCalled) return false;

            const giruda = this.contract.giruda;
            const isNoGiruda = this.contract.isNoGiruda;
            const leadSuit = this.trick.leadSuit;

            if (winningCard.isJoker) return true; // jokerCalledÎ°ú Î¨¥Ìö®ÌôîÎêú Ï°∞Ïª§

            const winSuit = winningCard.suit;
            const winValue = RANK_VALUES[winningCard.rank];

            // Ïù¥Í∏∞Í≥† ÏûàÎäî Ïπ¥ÎìúÍ∞Ä Í∏∞Î£®Îã§Ïù∏ Í≤ΩÏö∞
            if (!isNoGiruda && giruda && winSuit === giruda) {
                if (card.suit === giruda) return RANK_VALUES[card.rank] > winValue;
                return false;
            }

            // Ïù¥Í∏∞Í≥† ÏûàÎäî Ïπ¥ÎìúÍ∞Ä Î¶¨Îìú ÏàòÌä∏Ïù∏ Í≤ΩÏö∞
            if (winSuit === leadSuit) {
                if (!isNoGiruda && giruda && card.suit === giruda) return true;
                if (card.suit === leadSuit) return RANK_VALUES[card.rank] > winValue;
                return false;
            }

            // Í∑∏ Ïô∏
            if (!isNoGiruda && giruda && card.suit === giruda) return true;
            if (card.suit === leadSuit) return true;
            return false;
        });

        const pointsInTrick = this.trick.cards.reduce((sum, p) => {
            return sum + (p.card.isPointCard() ? 1 : 0);
        }, 0);

        // ‚òÖ Í∞úÏÑ†Îêú remainingPlayers Í≥ÑÏÇ∞
        const playedPlayers = new Set(this.trick.cards.map(p => p.player));
        playedPlayers.add(playerIndex);

        const remainingPlayers = [];
        let checkPlayer = this.getNextPlayer(playerIndex);
        let safety = 0;
        while (safety < GAME_CONFIG.PLAYER_COUNT) {
            if (playedPlayers.has(checkPlayer)) {
                checkPlayer = this.getNextPlayer(checkPlayer);
                safety++;
                continue;
            }
            if (this.trick.cards.length > 0 && checkPlayer === this.trick.leadPlayer) break;
            remainingPlayers.push(checkPlayer);
            playedPlayers.add(checkPlayer);
            checkPlayer = this.getNextPlayer(checkPlayer);
            safety++;
        }

        return {
            leadSuit: this.trick.leadSuit,
            currentWinner,
            isGovernmentWinning,
            isOppositionWinning,
            isUncertain,
            playableCards,
            canWin: cardsToWin.length > 0,
            cardsToWin,
            pointsInTrick,
            remainingPlayers,
            hasGovernmentRemaining: remainingPlayers.some(p => teamContext.governmentPlayers.includes(p)),
            hasOppositionRemaining: remainingPlayers.some(p => teamContext.oppositionPlayers.includes(p))
        };
    }

    // ===== Ïπ¥Îìú Ï∂îÏ†Å ÏãúÏä§ÌÖú =====
    initializeCardTracker() {
        const allCards = [];
        for (const suit of Object.values(SUITS)) {
            for (const rank of RANKS) allCards.push(new Card(suit, rank));
        }
        allCards.push(Card.createJoker());
        const allPointCards = allCards.filter(c => c.isPointCard());
        return {
            allCards,
            playedCards: [],
            remainingCards: [...allCards],
            playedPointCards: [],
            remainingPointCards: [...allPointCards],
            playerVoidSuits: new Map(),
            mightyPlayed: false,
            jokerPlayed: false
        };
    }

    updateCardTracker(playerIndex, card, leadSuit) {
        const tracker = this.cardTracker;
        tracker.playedCards.push({ player: playerIndex, card });
        tracker.remainingCards = tracker.remainingCards.filter(c => !c.equals(card));
        if (card.isPointCard()) {
            tracker.playedPointCards.push(card);
            tracker.remainingPointCards = tracker.remainingPointCards.filter(c => !c.equals(card));
        }
        if (this.contract.mighty && card.equals(this.contract.mighty)) tracker.mightyPlayed = true;
        if (card.isJoker) tracker.jokerPlayed = true;
        if (leadSuit && !card.isJoker && card.suit !== leadSuit) {
            if (!tracker.playerVoidSuits.has(playerIndex)) tracker.playerVoidSuits.set(playerIndex, new Set());
            tracker.playerVoidSuits.get(playerIndex).add(leadSuit);
        }
    }

    doesPlayerHaveSuit(playerIndex, suit) {
        const voidSuits = this.cardTracker.playerVoidSuits.get(playerIndex);
        if (voidSuits && voidSuits.has(suit)) return false;
        return null;
    }

    getRemainingPointCount() { return this.cardTracker.remainingPointCards.length; }

    getRemainingCardsOfSuit(suit) {
        return this.cardTracker.remainingCards.filter(c => !c.isJoker && c.suit === suit);
    }

    isMightyStillInPlay() { return !this.cardTracker.mightyPlayed; }
    isJokerStillInPlay() { return !this.cardTracker.jokerPlayed; }

    isCardStillInPlay(card) {
        return this.cardTracker.remainingCards.some(c => c.equals(card));
    }

    isBossCard(card) {
        if (!card || card.isJoker) return false;
        const suit = card.suit;
        const cardStrength = RANK_VALUES[card.rank];
        const remainingHigherCards = this.cardTracker.remainingCards.filter(c => {
            if (c.isJoker) return false;
            if (c.suit !== suit) return false;
            if (c.equals(card)) return false;
            return RANK_VALUES[c.rank] > cardStrength;
        });
        return remainingHigherCards.length === 0;
    }

    getBossCardOfSuit(suit) {
        const remainingCards = this.cardTracker.remainingCards.filter(c => !c.isJoker && c.suit === suit);
        if (remainingCards.length === 0) return null;
        remainingCards.sort((a, b) => RANK_VALUES[b.rank] - RANK_VALUES[a.rank]);
        return remainingCards[0];
    }

    getGirudaBossCard() {
        if (!this.contract.giruda) return null;
        return this.getBossCardOfSuit(this.contract.giruda);
    }

    getCardAnalysis(card) {
        if (!card || card.isJoker) return { card, isBoss: false, isGirudaBoss: false, higherCardsRemaining: 0 };
        const suit = card.suit;
        const cardStrength = RANK_VALUES[card.rank];
        const giruda = this.contract.giruda;
        const higherCardsRemaining = this.cardTracker.remainingCards.filter(c => {
            if (c.isJoker) return false;
            if (c.suit !== suit) return false;
            if (c.equals(card)) return false;
            return RANK_VALUES[c.rank] > cardStrength;
        }).length;
        const isBoss = higherCardsRemaining === 0;
        const isGirudaBoss = isBoss && suit === giruda;
        return { card, isBoss, isGirudaBoss, higherCardsRemaining };
    }

    estimatePlayerPossibleCards(playerIndex, myHand) {
        const tracker = this.cardTracker;
        const voidSuits = tracker.playerVoidSuits.get(playerIndex) || new Set();
        return tracker.remainingCards.filter(card => {
            if (myHand.some(c => c.equals(card))) return false;
            if (!card.isJoker && voidSuits.has(card.suit)) return false;
            return true;
        });
    }

    estimateMightyHolder(myIndex, myHand) {
        if (this.cardTracker.mightyPlayed) return { holder: -1, probability: 0 };
        const mighty = this.contract.mighty;
        if (hasCard(myHand, mighty)) return { holder: myIndex, probability: 1 };
        const possibleHolders = [];
        for (let i = 0; i < GAME_CONFIG.PLAYER_COUNT; i++) {
            if (i === myIndex) continue;
            const voidSuits = this.cardTracker.playerVoidSuits.get(i);
            if (voidSuits && voidSuits.has(mighty.suit)) continue;
            possibleHolders.push(i);
        }
        if (possibleHolders.length === 0) return { holder: -1, probability: 0 };
        return { holders: possibleHolders, probability: 1 / possibleHolders.length };
    }

    estimateJokerHolder(myIndex, myHand) {
        if (this.cardTracker.jokerPlayed) return { holder: -1, probability: 0 };
        if (myHand.some(c => c.isJoker)) return { holder: myIndex, probability: 1 };
        const possibleHolders = [];
        for (let i = 0; i < GAME_CONFIG.PLAYER_COUNT; i++) {
            if (i !== myIndex) possibleHolders.push(i);
        }
        return { holders: possibleHolders, probability: 1 / possibleHolders.length };
    }

    getCardTrackingSummary(myIndex, myHand) {
        return {
            totalPlayed: this.cardTracker.playedCards.length,
            remainingCount: this.cardTracker.remainingCards.length,
            pointsPlayed: this.cardTracker.playedPointCards.length,
            pointsRemaining: this.cardTracker.remainingPointCards.length,
            mightyPlayed: this.cardTracker.mightyPlayed,
            jokerPlayed: this.cardTracker.jokerPlayed,
            mightyHolder: this.estimateMightyHolder(myIndex, myHand),
            jokerHolder: this.estimateJokerHolder(myIndex, myHand),
            playerVoidSuits: Object.fromEntries(
                Array.from(this.cardTracker.playerVoidSuits.entries()).map(
                    ([k, v]) => [k, Array.from(v)]
                )
            )
        };
    }

    // ‚òÖ Í≤åÏûÑ Ï†ÄÏû•
    serialize() {
        try {
            return JSON.stringify({
                players: this.players.map(p => ({
                    index: p.index, name: p.name,
                    hand: p.hand.map(c => c.isJoker ? { isJoker: true } : { suit: c.suit, rank: c.rank }),
                    scoreCards: p.scoreCards.map(c => ({ suit: c.suit, rank: c.rank })),
                    role: p.role, totalScore: p.totalScore, hasPassed: p.hasPassed
                })),
                phase: this.phase, round: this.round, dealer: this.dealer,
                currentTurn: this.currentTurn,
                governmentScore: this.governmentScore, oppositionScore: this.oppositionScore,
                mightyUsed: this.mightyUsed, jokerUsed: this.jokerUsed,
                friendRevealed: this.friendRevealed, dealmeePool: this.dealmeePool
            });
        } catch (e) { return null; }
    }

    saveToLocal() {
        try { localStorage.setItem('mighty_game_save', this.serialize()); return true; }
        catch (e) { return false; }
    }
}

// ========================================
// ===== ai.js =====
// ========================================

class AI {
    constructor(gameState, settings) {
        this.gameState = gameState;
        this.settings = settings;
    }

    // ===== ÎπÑÎî© AI =====
    decideBid(playerIndex) {
        const player = this.gameState.players[playerIndex];
        const hand = player.hand;
        const currentBid = this.gameState.bidding.currentBid;
        const evaluation = this.evaluateHand(hand);
        const reasoning = [];

        reasoning.push(`ÏÜêÌå® ÌèâÍ∞Ä Ï†êÏàò: ${evaluation.totalScore.toFixed(1)}`);

        if (evaluation.shouldPass) {
            reasoning.push('Ìå®Í∞Ä ÏïΩÌïòÏó¨ Ìå®Ïä§');
            return { action: 'pass', reasoning };
        }

        if (!currentBid) {
            const suitName = evaluation.recommendedGiruda === 'none' ? 'ÎÖ∏Í∏∞Î£®Îã§' :
                (SUIT_NAMES[evaluation.recommendedGiruda] || 'Ïä§ÌéòÏù¥Îìú');
            reasoning.push(`Ï∂îÏ≤ú Í∏∞Î£®Îã§: ${suitName}`);
            return {
                action: 'bid',
                value: 13,
                suit: evaluation.recommendedGiruda || SUITS.SPADE,
                reasoning
            };
        }

        const myMaxBid = evaluation.recommendedBid;
        if (myMaxBid < currentBid.value) {
            reasoning.push(`ÏµúÎåÄ Í∞ÄÎä• ÎπÑÎî©(${myMaxBid})Ïù¥ ÌòÑÏû¨ ÎπÑÎî©(${currentBid.value})Î≥¥Îã§ ÎÇÆÏùå`);
            return { action: 'pass', reasoning };
        }

        let bidValue = currentBid.value;
        let bidSuit = evaluation.recommendedGiruda || SUITS.SPADE;

        if (this.gameState.isValidBid(bidValue, bidSuit)) {
            const sym = bidSuit === 'none' ? 'No' : SUIT_SYMBOLS[bidSuit];
            reasoning.push(`${bidValue}${sym} ÎπÑÎî©`);
            return { action: 'bid', value: bidValue, suit: bidSuit, reasoning };
        }

        bidValue = currentBid.value + 1;
        if (bidValue <= GAME_CONFIG.MAX_BID && bidValue <= myMaxBid) {
            const sym = bidSuit === 'none' ? 'No' : SUIT_SYMBOLS[bidSuit];
            reasoning.push(`${bidValue}${sym} ÎπÑÎî©`);
            return { action: 'bid', value: bidValue, suit: bidSuit, reasoning };
        }

        reasoning.push('Îçî ÎÜíÏùÄ ÎπÑÎî© Î∂àÍ∞Ä, Ìå®Ïä§');
        return { action: 'pass', reasoning };
    }

    // ‚òÖ Í∞úÏÑ†: ÎÖ∏Í∏∞Î£®Îã§ ÎπÑÎî© Ìè¨Ìï®
    evaluateHand(hand) {
        let totalScore = 0;
        const suitCounts = {};
        const suitStrengths = {};

        const baseMighty = new Card(SUITS.SPADE, 'A');
        const hasBaseMighty = hasCard(hand, baseMighty);
        if (hasBaseMighty) totalScore += 4;

        const hasJoker = hand.some(c => c.isJoker);
        if (hasJoker) totalScore += 3;

        for (const suit of Object.values(SUITS)) {
            const suitCards = getCardsOfSuit(hand, suit);
            suitCounts[suit] = suitCards.length;
            let strength = suitCards.length * 1.5;
            if (suitCards.some(c => c.rank === 'A')) strength += 2;
            if (suitCards.some(c => c.rank === 'K')) strength += 1.5;
            if (suitCards.some(c => c.rank === 'Q')) strength += 1;
            strength += suitCards.filter(c => POINT_RANKS.includes(c.rank)).length * 0.5;
            suitStrengths[suit] = strength;
        }

        let bestSuit = null;
        let bestStrength = 0;
        for (const suit of Object.values(SUITS)) {
            if (suitCounts[suit] >= 3 && suitStrengths[suit] > bestStrength) {
                bestStrength = suitStrengths[suit];
                bestSuit = suit;
            }
        }

        // ‚òÖ ÎÖ∏Í∏∞Î£®Îã§ ÌèâÍ∞Ä
        let noGirudaScore = 0;
        const aceCount = hand.filter(c => !c.isJoker && c.rank === 'A').length;
        const kingCount = hand.filter(c => !c.isJoker && c.rank === 'K').length;
        if (hasBaseMighty) noGirudaScore += 4;
        if (hasJoker) noGirudaScore += 3;
        noGirudaScore += aceCount * 2.5;
        noGirudaScore += kingCount * 1.5;
        const maxSuitCount = Math.max(...Object.values(suitCounts));
        const nonZeroCounts = Object.values(suitCounts).filter(c => c > 0);
        const minSuitCount = nonZeroCounts.length > 0 ? Math.min(...nonZeroCounts) : 0;
        if (maxSuitCount - minSuitCount <= 2) noGirudaScore += 2;

        let recommendedGiruda = bestSuit;
        let effectiveScore = totalScore;

        if (noGirudaScore > totalScore + 2) {
            recommendedGiruda = 'none';
            effectiveScore = noGirudaScore;
        }

        if (bestSuit && recommendedGiruda !== 'none') {
            totalScore += suitCounts[bestSuit];
            const highCards = getCardsOfSuit(hand, bestSuit)
                .filter(c => POINT_RANKS.includes(c.rank));
            totalScore += highCards.length * 1.5;
            effectiveScore = totalScore;
        }

        for (const suit of Object.values(SUITS)) {
            if (suit === SUITS.SPADE) continue;
            const suitCards = getCardsOfSuit(hand, suit);
            if (suitCards.some(c => c.rank === 'A')) effectiveScore += 1;
        }

        let recommendedBid = 13;
        let shouldPass = true;
        if (effectiveScore >= 7) {
            shouldPass = false;
            recommendedBid = Math.min(13 + Math.floor((effectiveScore - 7) / 2), GAME_CONFIG.MAX_BID);
        }

        return {
            totalScore: effectiveScore, hasMighty: hasBaseMighty, hasJoker,
            suitCounts, suitStrengths, recommendedGiruda, recommendedBid,
            shouldPass, noGirudaScore
        };
    }

    // ===== ÏπúÍµ¨ ÏÑ†Ïñ∏ AI =====
    selectFriendCard(playerIndex) {
        const player = this.gameState.players[playerIndex];
        const hand = player.hand;
        const giruda = this.gameState.contract.giruda;
        const mighty = this.gameState.contract.mighty;
        const reasoning = [];

        const hasMighty = hasCard(hand, mighty);
        const hasJoker = hand.some(c => c.isJoker);
        const girudaAce = giruda ? new Card(giruda, 'A') : null;
        const hasGirudaAce = girudaAce && (hasCard(hand, girudaAce) || girudaAce.equals(mighty));
        const girudaCards = giruda ? hand.filter(c => !c.isJoker && c.suit === giruda) : [];
        const girudaCount = girudaCards.length;

        reasoning.push(`ÎßàÏù¥Ìã∞ Î≥¥Ïú†: ${hasMighty ? 'Ïòà' : 'ÏïÑÎãàÏò§'}`);
        reasoning.push(`Ï°∞Ïª§ Î≥¥Ïú†: ${hasJoker ? 'Ïòà' : 'ÏïÑÎãàÏò§'}`);
        if (giruda) reasoning.push(`Í∏∞Î£®Îã§ Ïàò: ${girudaCount}Ïû•`);

        const candidates = [];

        if (!hasMighty) {
            reasoning.push('ÎßàÏù¥Ìã∞ ÎØ∏Î≥¥Ïú† ‚Üí ÎßàÏù¥Ìã∞ ÏπúÍµ¨ Ïö∞ÏÑ†');
            candidates.push({ card: mighty, priority: 1, reason: 'ÎßàÏù¥Ìã∞ ÎØ∏Î≥¥Ïú† - ÎßàÏù¥Ìã∞ ÏπúÍµ¨' });
        }

        if (hasMighty && !hasJoker) {
            const joker = Card.createJoker();
            reasoning.push('ÎßàÏù¥Ìã∞ Î≥¥Ïú† + Ï°∞Ïª§ ÎØ∏Î≥¥Ïú† ‚Üí Ï°∞Ïª§ ÏπúÍµ¨ Ïö∞ÏÑ†');
            candidates.push({ card: joker, priority: 1, reason: 'ÎßàÏù¥Ìã∞ Î≥¥Ïú†, Ï°∞Ïª§ ÎØ∏Î≥¥Ïú† - Ï°∞Ïª§ ÏπúÍµ¨' });
        }

        if (hasMighty && hasJoker) {
            reasoning.push('ÎßàÏù¥Ìã∞ + Ï°∞Ïª§ Î≥¥Ïú† ‚Üí Í∏∞Î£®Îã§ A ÎòêÎäî K ÏπúÍµ¨');
            if (girudaAce && !girudaAce.equals(mighty) && !hasCard(hand, girudaAce)) {
                candidates.push({ card: girudaAce, priority: 1, reason: 'ÎßàÏù¥Ìã∞+Ï°∞Ïª§ Î≥¥Ïú† - Í∏∞Î£®Îã§ A ÏπúÍµ¨' });
            }
            if (giruda) {
                const girudaKing = new Card(giruda, 'K');
                if (!hasCard(hand, girudaKing)) {
                    candidates.push({ card: girudaKing, priority: 2, reason: 'ÎßàÏù¥Ìã∞+Ï°∞Ïª§ Î≥¥Ïú† - Í∏∞Î£®Îã§ K ÏπúÍµ¨' });
                }
            }
        }

        if (hasMighty && girudaCount <= 2 && giruda) {
            if (girudaAce && !girudaAce.equals(mighty) && !hasCard(hand, girudaAce)) {
                candidates.push({ card: girudaAce, priority: 2, reason: 'Í∏∞Î£®Îã§ ÏïΩÌï® - Í∏∞Î£®Îã§ A ÏπúÍµ¨' });
            }
            const girudaKing = new Card(giruda, 'K');
            if (!hasCard(hand, girudaKing)) {
                candidates.push({ card: girudaKing, priority: 3, reason: 'Í∏∞Î£®Îã§ ÏïΩÌï® - Í∏∞Î£®Îã§ K ÏπúÍµ¨' });
            }
        }

        // Î∞±ÏóÖ ÌõÑÎ≥¥
        if (girudaAce && !girudaAce.equals(mighty) && !hasCard(hand, girudaAce)) {
            candidates.push({ card: girudaAce, priority: 10, reason: 'Î∞±ÏóÖ - Í∏∞Î£®Îã§ A' });
        }
        if (!hasMighty) {
            candidates.push({ card: mighty, priority: 11, reason: 'Î∞±ÏóÖ - ÎßàÏù¥Ìã∞' });
        }
        const joker = Card.createJoker();
        if (!hasJoker) {
            candidates.push({ card: joker, priority: 12, reason: 'Î∞±ÏóÖ - Ï°∞Ïª§' });
        }
        for (const suit of Object.values(SUITS)) {
            if (suit === giruda) continue;
            const ace = new Card(suit, 'A');
            if (!ace.equals(mighty) && !hasCard(hand, ace)) {
                candidates.push({ card: ace, priority: 20, reason: `Î∞±ÏóÖ - ${SUIT_NAMES[suit]} A` });
            }
        }
        if (giruda) {
            const girudaKing = new Card(giruda, 'K');
            if (!hasCard(hand, girudaKing)) {
                candidates.push({ card: girudaKing, priority: 21, reason: 'Î∞±ÏóÖ - Í∏∞Î£®Îã§ K' });
            }
        }

        if (candidates.length === 0) {
            reasoning.push('Î™®Îì† Ï¢ãÏùÄ Ïπ¥ÎìúÎ•º Î≥¥Ïú† Ï§ë - ÎÖ∏ÌîÑÎ†åÎìú');
            return { card: null, isNoFriend: true, reasoning };
        }

        const uniqueCandidates = [];
        const seen = new Set();
        for (const c of candidates) {
            const key = c.card.toString();
            if (!seen.has(key)) { seen.add(key); uniqueCandidates.push(c); }
        }
        uniqueCandidates.sort((a, b) => a.priority - b.priority);
        const selected = uniqueCandidates[0];
        reasoning.push(`ÏπúÍµ¨ Ïπ¥Îìú ÏÑ†ÌÉù: ${selected.card.toString()} (${selected.reason})`);
        return { card: selected.card, isNoFriend: false, reasoning };
    }

    // ===== Ïπ¥Îìú ÍµêÌôò AI =====
    selectCardsToDiscard(playerIndex) {
        const player = this.gameState.players[playerIndex];
        const hand = [...player.hand];
        const currentGiruda = this.gameState.contract.giruda;
        const currentBid = this.gameState.contract.bidValue;
        const reasoning = [];

        const girudaChangeDecision = this.shouldChangeGiruda(hand, currentGiruda, currentBid);
        const giruda = girudaChangeDecision.newGiruda || currentGiruda;
        const mighty = giruda === SUITS.SPADE
            ? new Card(SUITS.DIAMOND, 'A')
            : new Card(SUITS.SPADE, 'A');

        const mustKeep = new Set();
        mustKeep.add(mighty.toString());
        if (hand.some(c => c.isJoker)) mustKeep.add('JOKER');

        const suitCounts = {};
        for (const suit of Object.values(SUITS)) {
            suitCounts[suit] = getCardsOfSuit(hand, suit).length;
        }

        const getDiscardPriority = (card) => {
            if (mustKeep.has(card.toString())) return 1000;
            let priority = 0;
            if (card.isPointCard()) priority += 100;
            if (!card.isJoker && giruda && card.suit === giruda) priority += 50;
            if (!card.isJoker) priority += RANK_VALUES[card.rank];
            if (!card.isJoker) priority -= suitCounts[card.suit] * 10;
            return priority;
        };

        const sorted = [...hand].sort((a, b) => getDiscardPriority(a) - getDiscardPriority(b));
        const toDiscard = sorted.slice(0, 3).filter(c => !mustKeep.has(c.toString()));

        while (toDiscard.length < 3) {
            for (const card of sorted) {
                if (!toDiscard.some(c => c.equals(card)) && !mustKeep.has(card.toString())) {
                    toDiscard.push(card); break;
                }
            }
            if (toDiscard.length < 3) {
                for (const card of sorted) {
                    if (!toDiscard.some(c => c.equals(card))) { toDiscard.push(card); break; }
                }
            }
        }

        reasoning.push(`Î≤ÑÎ¶¥ Ïπ¥Îìú: ${toDiscard.map(c => c.toString()).join(', ')}`);
        if (girudaChangeDecision.shouldChange) reasoning.unshift(girudaChangeDecision.reason);

        return {
            cards: toDiscard.slice(0, 3),
            reasoning,
            newGiruda: girudaChangeDecision.shouldChange ? girudaChangeDecision.newGiruda : null,
            isNoGiruda: girudaChangeDecision.isNoGiruda || false,
            isSolino: girudaChangeDecision.isSolino || false
        };
    }

    shouldChangeGiruda(hand, currentGiruda, currentBid) {
        const isMaxBid = currentBid >= GAME_CONFIG.MAX_BID;
        const suitAnalysis = {};
        for (const suit of Object.values(SUITS)) {
            const suitCards = getCardsOfSuit(hand, suit);
            const count = suitCards.length;
            const highCards = suitCards.filter(c => ['A', 'K', 'Q', 'J'].includes(c.rank));
            const strength = count * 2 + highCards.length * 1.5;
            suitAnalysis[suit] = { count, highCards: highCards.length, strength };
        }

        const baseMighty = new Card(SUITS.SPADE, 'A');
        const hasMighty = hasCard(hand, baseMighty);
        const hasJoker = hand.some(c => c.isJoker);

        if (isMaxBid) {
            const currentAnalysis = currentGiruda ? suitAnalysis[currentGiruda] : { count: 0, strength: 0 };
            if (hasMighty && hasJoker && currentAnalysis.count >= 6 && currentAnalysis.highCards >= 3) {
                return { shouldChange: true, newGiruda: null, isNoGiruda: false, isSolino: true, reason: 'ÏÜîÎ¶¨ÎÖ∏ ÏÑ†Ïñ∏ (Îß§Ïö∞ Í∞ïÌïú Ìå®)' };
            }
            let bestSuit = currentGiruda;
            let bestStrength = currentGiruda ? suitAnalysis[currentGiruda].strength : 0;
            for (const [suit, analysis] of Object.entries(suitAnalysis)) {
                if (analysis.strength > bestStrength) { bestSuit = suit; bestStrength = analysis.strength; }
            }
            if (bestSuit && bestSuit !== currentGiruda) {
                const oldName = currentGiruda ? SUIT_NAMES[currentGiruda] : 'ÎÖ∏Í∏∞Î£®Îã§';
                return { shouldChange: true, newGiruda: bestSuit, isNoGiruda: false, isSolino: false, reason: `Í∏∞Î£®Îã§ Î¨¥Î£å Î≥ÄÍ≤Ω: ${oldName} ‚Üí ${SUIT_NAMES[bestSuit]}` };
            }
            return { shouldChange: false, newGiruda: null, isNoGiruda: false, isSolino: false, reason: null };
        }

        const currentAnalysis = currentGiruda ? suitAnalysis[currentGiruda] : { count: 0, strength: 0 };
        let bestSuit = currentGiruda;
        let bestStrength = currentAnalysis.strength;
        for (const [suit, analysis] of Object.entries(suitAnalysis)) {
            if (suit !== currentGiruda) {
                const countDiff = analysis.count - currentAnalysis.count;
                const strengthDiff = analysis.strength - currentAnalysis.strength;
                if ((countDiff >= 2 || strengthDiff >= 5) && analysis.strength > bestStrength) {
                    bestSuit = suit; bestStrength = analysis.strength;
                }
            }
        }
        if (bestSuit && bestSuit !== currentGiruda) {
            const newBid = Math.min(currentBid + 2, GAME_CONFIG.MAX_BID);
            const oldName = currentGiruda ? SUIT_NAMES[currentGiruda] : 'ÎÖ∏Í∏∞Î£®Îã§';
            return { shouldChange: true, newGiruda: bestSuit, reason: `Í∏∞Î£®Îã§ Î≥ÄÍ≤Ω: ${oldName} ‚Üí ${SUIT_NAMES[bestSuit]} (Í≥µÏïΩ ${currentBid} ‚Üí ${newBid})` };
        }
        return { shouldChange: false, newGiruda: null, reason: null };
    }

    // ===== Ïπ¥Îìú ÌîåÎ†àÏù¥ AI =====
    selectCardToPlay(playerIndex) {
        const player = this.gameState.players[playerIndex];
        const hand = player.hand;
        const teamContext = this.gameState.getTeamContext(playerIndex);
        const trickAnalysis = this.gameState.analyzeTrick(playerIndex);
        const round = this.gameState.round;
        const reasoning = [];
        const trackingSummary = this.gameState.getCardTrackingSummary(playerIndex, hand);

        const isLead = this.gameState.trick.cards.length === 0;
        const isGovernment = teamContext.myRole === ROLES.MASTER || teamContext.myRole === ROLES.FRIEND;

        reasoning.push(`Ïó≠Ìï†: ${player.getRoleText() || 'ÏïºÎãπ'}`);
        reasoning.push(`ÎÇ®ÏùÄ Ï†êÏàò: ${trackingSummary.pointsRemaining}Ï†ê`);

        // Ï°∞Ïª§ÏΩú ÎãπÌïú Í≤ΩÏö∞
        if (this.gameState.trick.jokerCalled) {
            const joker = hand.find(c => c.isJoker);
            if (joker) {
                const mighty = this.gameState.contract.mighty;
                if (hasCard(hand, mighty)) {
                    const shouldDefend = this.shouldDefendJokerCallWithMighty(hand, isGovernment, round);
                    if (shouldDefend) {
                        reasoning.push('Ï°∞Ïª§ÏΩú - ÎßàÏù¥Ìã∞Î°ú Î∞©Ïñ¥ (Ï°∞Ïª§ Î≥¥Ï°¥)');
                        return { card: mighty, reasoning };
                    }
                }
                reasoning.push('Ï°∞Ïª§ÏΩú - Ï°∞Ïª§ Í∞ïÏ†ú Ï∂úÏ†Ñ');
                return { card: joker, reasoning };
            }
        }

        let selectedCard;
        if (isLead) {
            reasoning.push('ÏÑ†(Î¶¨Îìú) Ï∞®Î°Ä');
            selectedCard = isGovernment
                ? this.governmentLeadStrategy(hand, trickAnalysis, teamContext, reasoning, trackingSummary)
                : this.oppositionLeadStrategy(hand, trickAnalysis, teamContext, reasoning, trackingSummary);
        } else {
            reasoning.push(`Î¶¨Îìú ÏàòÌä∏: ${SUIT_NAMES[trickAnalysis.leadSuit] || 'ÏóÜÏùå'}`);
            if (trickAnalysis.isGovernmentWinning) reasoning.push('ÌòÑÏû¨ Ïó¨ÎãπÏù¥ Ïù¥Í∏∞Îäî Ï§ë');
            else if (trickAnalysis.isOppositionWinning) reasoning.push('ÌòÑÏû¨ ÏïºÎãπÏù¥ Ïù¥Í∏∞Îäî Ï§ë');
            reasoning.push(`Ìä∏Î¶≠ ÎÇ¥ Ï†êÏàò: ${trickAnalysis.pointsInTrick}Ï†ê`);

            selectedCard = isGovernment
                ? this.governmentFollowStrategy(hand, trickAnalysis, teamContext, reasoning, trackingSummary)
                : this.oppositionFollowStrategy(hand, trickAnalysis, teamContext, reasoning, trackingSummary);
        }

        reasoning.push(`ÏÑ†ÌÉù: ${selectedCard.toString()}`);

        let jokerCallSuit = null;
        if (isLead && selectedCard.isJoker && round >= 2 && round <= 9) {
            jokerCallSuit = this.selectJokerCallSuit(hand, teamContext);
            reasoning.push(`Ï°∞Ïª§ ÏàòÌä∏ ÏÑ†Ïñ∏: ${SUIT_NAMES[jokerCallSuit]}`);
        }

        return { card: selectedCard, jokerCallSuit, reasoning };
    }

    shouldDefendJokerCallWithMighty(hand, isGovernment, round) {
        const remainingRounds = 10 - round;
        if (remainingRounds <= 3) return true;
        if (isGovernment && round <= 5) return false;
        return true;
    }

    shouldPlayJoker(hand, trickAnalysis, teamContext, isLead, round, trackingSummary = null) {
        if (round === 1 || round === 10) return { shouldPlay: false };
        const isGovernment = teamContext.myRole === ROLES.MASTER || teamContext.myRole === ROLES.FRIEND;
        const { isGovernmentWinning, isOppositionWinning, pointsInTrick, hasGovernmentRemaining } = trickAnalysis;
        const mightyPlayed = trackingSummary ? trackingSummary.mightyPlayed : this.gameState.mightyUsed;
        const remainingPoints = trackingSummary ? trackingSummary.pointsRemaining : 20 - round * 2;

        if (isLead) {
            if (!isGovernment && !mightyPlayed) {
                if (round >= 8 || remainingPoints <= 4) return { shouldPlay: true, callSuit: this.selectJokerCallSuit(hand, teamContext) };
                return { shouldPlay: false };
            }
            if (round >= 6 || remainingPoints >= 8) return { shouldPlay: true, callSuit: this.selectJokerCallSuit(hand, teamContext) };
            return { shouldPlay: false };
        }

        const mightyPlayedInTrick = this.gameState.trick.cards.some(p => p.card.equals(this.gameState.contract.mighty));
        if (mightyPlayedInTrick) return { shouldPlay: false };

        if (!isGovernment) {
            if (!mightyPlayed) {
                if (hasGovernmentRemaining) {
                    if (pointsInTrick < 4 && round < 8) return { shouldPlay: false };
                }
                if (pointsInTrick < 3 && round < 7) return { shouldPlay: false };
            }
            if (isGovernmentWinning && pointsInTrick >= 2) return { shouldPlay: true };
            if (mightyPlayed && isGovernmentWinning && pointsInTrick >= 1) return { shouldPlay: true };
            return { shouldPlay: false };
        }

        if (isGovernment && isOppositionWinning && pointsInTrick >= 3) return { shouldPlay: true };
        return { shouldPlay: false };
    }

    shouldPlayMighty(hand, trickAnalysis, teamContext, isLead, round, trackingSummary = null) {
        const mighty = this.gameState.contract.mighty;
        if (!hasCard(hand, mighty)) return false;
        const isGovernment = teamContext.myRole === ROLES.MASTER || teamContext.myRole === ROLES.FRIEND;
        const isFriend = teamContext.myRole === ROLES.FRIEND;
        const { isGovernmentWinning, isOppositionWinning, pointsInTrick, playableCards } = trickAnalysis;

        if (playableCards.length === 1 && playableCards[0].equals(mighty)) return true;

        const remainingPoints = trackingSummary ? trackingSummary.pointsRemaining : 20 - round * 2;
        const jokerStillInPlay = trackingSummary ? !trackingSummary.jokerPlayed : true;

        if (isLead) {
            if (round >= 7) return true;
            if (remainingPoints >= 10 && !jokerStillInPlay) return true;
            return false;
        }

        const leadPlayer = this.gameState.trick.leadPlayer;
        const masterIndex = this.gameState.contract.master;
        const isMasterLead = (leadPlayer === masterIndex);

        if (isGovernment) {
            if (isFriend && isMasterLead && isOppositionWinning) {
                const hasOppRemaining = trickAnalysis.hasOppositionRemaining;
                if (pointsInTrick >= 1 || !hasOppRemaining) return true;
                if (round >= 5) return true;
            }
            if (isOppositionWinning && pointsInTrick >= 4) return true;
            const pointsNeeded = this.gameState.contract.bidValue - this.gameState.governmentScore;
            if (round >= 8 && pointsNeeded > 0 && pointsInTrick >= 2) return true;
            if (remainingPoints <= 6 && pointsInTrick >= 2 && isOppositionWinning) return true;
        } else {
            if (isGovernmentWinning && pointsInTrick >= 4) return true;
            if (this.gameState.governmentScore === 0 && round >= 7 && pointsInTrick >= 2) return true;
            if (remainingPoints <= 6 && pointsInTrick >= 2 && isGovernmentWinning) return true;
        }
        return false;
    }

    // ===== Ïó¨Îãπ Î¶¨Îìú Ï†ÑÎûµ =====
    governmentLeadStrategy(hand, trickAnalysis, teamContext, reasoning, trackingSummary = null) {
        const { playableCards } = trickAnalysis;
        const giruda = this.gameState.contract.giruda;
        const mighty = this.gameState.contract.mighty;
        const round = this.gameState.round;
        const friendCard = this.gameState.contract.friendCard;
        const friendRevealed = this.gameState.contract.friendRevealed;
        const isFriend = teamContext.myRole === ROLES.FRIEND;

        const govScore = this.gameState.governmentScore;
        const bidValue = this.gameState.contract.bidValue;
        const pointsNeeded = bidValue - govScore;

        if (pointsNeeded <= 0) {
            reasoning.push('Í≥µÏïΩ Îã¨ÏÑ± ÏôÑÎ£å - Î∞©Ïñ¥Ï†Å ÌîåÎ†àÏù¥');
            return this.selectLowestNonPointCard(playableCards) || this.selectLowestCard(playableCards);
        }

        const hasMighty = hasCard(hand, mighty);
        const hasJoker = hand.some(c => c.isJoker);
        const joker = hand.find(c => c.isJoker);
        const jokerCall = this.gameState.contract.jokerCall;

        // ‚òÖ Ï¥àÍµ¨ Ï†ÑÎûµ
        if (round === 1 && teamContext.myRole === ROLES.MASTER) {
            reasoning.push('Ï¥àÍµ¨ Ï†ÑÎûµ');
            const isFriendMighty = friendCard && friendCard.equals(mighty);
            const isFriendJoker = friendCard && friendCard.isJoker;

            if (hasMighty) {
                reasoning.push('Ï¥àÍµ¨ - ÎßàÏù¥Ìã∞ Î¶¨Îìú');
                return mighty;
            }

            if (isFriendMighty) {
                reasoning.push('Ï¥àÍµ¨ - ÏπúÍµ¨Í∞Ä ÎßàÏù¥Ìã∞ (ÎÇÆÏùÄ Ïπ¥ÎìúÎ°ú Ïú†ÎèÑ)');
                const nonGirudaCards = playableCards.filter(c => !c.isJoker && c.suit !== giruda && !c.isPointCard());
                if (nonGirudaCards.length > 0) return this.selectLowestCard(nonGirudaCards);
                const nonPointCards = playableCards.filter(c => !c.isJoker && !c.isPointCard());
                if (nonPointCards.length > 0) return this.selectLowestCard(nonPointCards);
                return this.selectLowestCard(playableCards);
            }

            if (isFriendJoker) {
                reasoning.push('Ï¥àÍµ¨ - ÏπúÍµ¨Í∞Ä Ï°∞Ïª§ (1ÎùºÏö¥Îìú Ï°∞Ïª§ Î¨¥Ìö®)');
                if (giruda) {
                    const girudaCards = getCardsOfSuit(hand, giruda);
                    for (const card of girudaCards) {
                        const analysis = this.gameState.getCardAnalysis(card);
                        if (analysis.isBoss) { reasoning.push('Ï¥àÍµ¨ - Í∏∞Î£®Îã§ Î≥¥Ïä§Ïπ¥Îìú Î¶¨Îìú'); return card; }
                    }
                }
            }

            const girudaAce = giruda ? new Card(giruda, 'A') : null;
            if (friendCard && girudaAce && friendCard.equals(girudaAce) && giruda) {
                reasoning.push('Ï¥àÍµ¨ - ÏπúÍµ¨Í∞Ä Í∏∞Î£®Îã§ A (Í∏∞Î£®Îã§ Î¶¨Îìú)');
                const girudaCards = getCardsOfSuit(hand, giruda);
                if (girudaCards.length > 0) return this.selectLowestCard(girudaCards);
            }

            // ‚òÖ Ï¥àÍµ¨ÏóêÏÑú Ï°∞Ïª§ÏΩú Ïπ¥Îìú Î¶¨Îìú Î∞©ÏßÄ
            const bossCards = playableCards.filter(c => {
                if (c.isJoker || c.equals(mighty)) return false;
                if (round === 1 && jokerCall && c.equals(jokerCall)) return false;
                const analysis = this.gameState.getCardAnalysis(c);
                return analysis.isBoss;
            });
            if (bossCards.length > 0) {
                const girudaBoss = bossCards.find(c => c.suit === giruda);
                if (girudaBoss) { reasoning.push('Ï¥àÍµ¨ - Í∏∞Î£®Îã§ Î≥¥Ïä§Ïπ¥Îìú Î¶¨Îìú'); return girudaBoss; }
                const pointBoss = bossCards.filter(c => c.isPointCard());
                if (pointBoss.length > 0) { reasoning.push('Ï¥àÍµ¨ - Ï†êÏàò Î≥¥Ïä§Ïπ¥Îìú Î¶¨Îìú'); return this.selectHighestCard(pointBoss); }
            }

            reasoning.push('Ï¥àÍµ¨ - ÎÇÆÏùÄ Ïπ¥ÎìúÎ°ú ÏπúÍµ¨ Ïú†ÎèÑ');
            const nonPointCards = playableCards.filter(c => !c.isJoker && !c.isPointCard());
            if (nonPointCards.length > 0) return this.selectLowestCard(nonPointCards);
            return this.selectLowestCard(playableCards);
        }

        // ÎßàÏù¥Ìã∞/Ï°∞Ïª§ ÏÇ¨Ïö© Í≤∞Ï†ï
        if (this.shouldPlayMighty(hand, trickAnalysis, teamContext, true, round, trackingSummary)) {
            reasoning.push('ÎßàÏù¥Ìã∞ Î¶¨Îìú'); return mighty;
        }
        const jokerDecision = this.shouldPlayJoker(hand, trickAnalysis, teamContext, true, round, trackingSummary);
        if (jokerDecision.shouldPlay && hasJoker) { reasoning.push('Ï°∞Ïª§ Î¶¨Îìú'); return joker; }

        // Ï°∞Ïª§ÏΩú Ï†ÑÎûµ
        const hasJokerCallCard = jokerCall && hand.some(c => c.equals(jokerCall));
        const isJokerStillOut = !this.gameState.jokerUsed;
        if (round >= 2 && round <= 9 && hasJokerCallCard && isJokerStillOut) {
            const iHaveJoker = hand.some(c => c.isJoker);
            if (!iHaveJoker) {
                if (round >= 5) { reasoning.push('Ï°∞Ïª§ÏΩú - ÏïºÎãπ Ï°∞Ïª§ Í≤¨Ï†ú'); return jokerCall; }
            }
        }

        // ‚òÖ ÏàòÌä∏ Ï†àÏ†ú(Void) Ï†ÑÎûµ
        if (giruda) {
            const girudaCardsInHand = getCardsOfSuit(hand, giruda);
            if (girudaCardsInHand.length > 0) {
                const shortSuits = [];
                for (const suit of Object.values(SUITS)) {
                    if (suit === giruda) continue;
                    const suitCards = getCardsOfSuit(hand, suit);
                    if (suitCards.length === 1 || suitCards.length === 2) {
                        shortSuits.push({ suit, cards: suitCards, count: suitCards.length });
                    }
                }
                for (const ss of shortSuits.sort((a, b) => a.count - b.count)) {
                    const bosses = ss.cards.filter(c => {
                        const analysis = this.gameState.getCardAnalysis(c);
                        return analysis.isBoss;
                    });
                    if (bosses.length > 0) {
                        reasoning.push(`ÏàòÌä∏ Ï†àÏ†ú - ${SUIT_NAMES[ss.suit]} Î≥¥Ïä§Ïπ¥Îìú Î¶¨Îìú (${ss.count}Ïû•)`);
                        return this.selectHighestCard(bosses);
                    }
                }
            }
        }

        // ÏπúÍµ¨ Î¶¨Îìú Ïãú Î≥¥Ïä§Ïπ¥Îìú
        const bossCards2 = playableCards.filter(c => {
            if (c.isJoker || c.equals(mighty)) return false;
            const analysis = this.gameState.getCardAnalysis(c);
            return analysis.isBoss;
        });
        const hasBossCard = bossCards2.length > 0;

        if (isFriend && bossCards2.length > 0) {
            reasoning.push('ÏπúÍµ¨ Î¶¨Îìú - Î≥¥Ïä§Ïπ¥ÎìúÎ°ú Ï£ºÍ≥µ ÏßÄÏõê');
            const girudaBoss = bossCards2.find(c => c.suit === giruda);
            if (girudaBoss) return girudaBoss;
            const pointBoss = bossCards2.filter(c => c.isPointCard());
            if (pointBoss.length > 0) return this.selectHighestCard(pointBoss);
            return this.selectHighestCard(bossCards2);
        }

        // Í∏∞Î£®Îã§ Î≥¥Ïä§Ïπ¥Îìú Î¶¨Îìú
        if (giruda) {
            const girudaCards = getCardsOfSuit(hand, giruda);
            if (girudaCards.length > 0) {
                const highGiruda = girudaCards.filter(c => ['A', 'K', 'Q'].includes(c.rank));
                for (const card of highGiruda) {
                    const analysis = this.gameState.getCardAnalysis(card);
                    if (analysis.isBoss) { reasoning.push('Í∏∞Î£®Îã§ Î≥¥Ïä§Ïπ¥Îìú Î¶¨Îìú'); return card; }
                }
            }
        }

        // A Î¶¨Îìú (Î≥¥Ïä§Ïπ¥Îìú)
        for (const suit of Object.values(SUITS)) {
            if (suit === giruda) continue;
            const suitCards = getCardsOfSuit(hand, suit);
            const ace = suitCards.find(c => c.rank === 'A');
            if (ace) {
                const analysis = this.gameState.getCardAnalysis(ace);
                if (analysis.isBoss) { reasoning.push(`${SUIT_NAMES[suit]} A Î¶¨Îìú`); return ace; }
            }
        }

        // ÏπúÍµ¨ÏóêÍ≤å Ìä∏Î¶≠ ÎÑòÍ∏∞Í∏∞
        let friendCardSuit = null;
        let friendCardRank = null;
        if (friendCard && !friendCard.isJoker) { friendCardSuit = friendCard.suit; friendCardRank = friendCard.rank; }

        if (!hasBossCard && friendCard && !friendCard.isJoker && friendCardSuit) {
            const sameSuitCards = getCardsOfSuit(hand, friendCardSuit);
            if (sameSuitCards.length > 0) {
                const lowerCards = sameSuitCards.filter(c => RANK_VALUES[c.rank] < RANK_VALUES[friendCardRank]);
                if (lowerCards.length > 0 && this.gameState.isCardStillInPlay(friendCard)) {
                    reasoning.push(`ÏπúÍµ¨ Ïπ¥Îìú(${friendCard.toString()}) ÌôúÏö©`);
                    return this.selectLowestCard(lowerCards);
                }
            }
        }

        // Í∞ÄÏû• Í∏¥ ÏàòÌä∏ Î¶¨Îìú
        const longestSuit = this.findLongestSuit(hand, giruda);
        if (longestSuit) {
            const suitCards = getCardsOfSuit(hand, longestSuit);
            if (suitCards.length > 0) {
                const bossInSuit = suitCards.find(c => {
                    const analysis = this.gameState.getCardAnalysis(c);
                    return analysis.isBoss;
                });
                if (bossInSuit) { reasoning.push(`${SUIT_NAMES[longestSuit]} Î≥¥Ïä§Ïπ¥Îìú Î¶¨Îìú`); return bossInSuit; }
                reasoning.push(`${SUIT_NAMES[longestSuit]} Î¶¨Îìú (ÎÇÆÏùÄ Ïπ¥Îìú)`);
                return this.selectLowestCard(suitCards);
            }
        }

        if (hasBossCard) return this.selectHighestCard(playableCards);
        return this.selectLowestCard(playableCards);
    }

    // ===== ÏïºÎãπ Î¶¨Îìú Ï†ÑÎûµ =====
    oppositionLeadStrategy(hand, trickAnalysis, teamContext, reasoning, trackingSummary = null) {
        const { playableCards } = trickAnalysis;
        const giruda = this.gameState.contract.giruda;
        const mighty = this.gameState.contract.mighty;
        const masterIndex = this.gameState.contract.master;
        const round = this.gameState.round;

        const govScore = this.gameState.governmentScore;
        const bidValue = this.gameState.contract.bidValue;
        const pointsNeeded = bidValue - govScore;
        const remainingRounds = 10 - round + 1;
        const isGovernmentClose = pointsNeeded <= remainingRounds * 2;

        // ‚òÖ ÏïºÎãπ Ï°∞Ïª§ÏΩú Ï†ÑÎûµ
        const jokerCall = this.gameState.contract.jokerCall;
        const hasJokerCallCard = jokerCall && hand.some(c => c.equals(jokerCall));
        const isJokerStillOut = !this.gameState.jokerUsed;
        const iHaveJoker = hand.some(c => c.isJoker);

        if (round >= 2 && round <= 9 && hasJokerCallCard && isJokerStillOut && !iHaveJoker) {
            const mightyPlayed = this.gameState.mightyUsed;
            if (mightyPlayed) {
                reasoning.push('Ï°∞Ïª§ÏΩú - ÎßàÏù¥Ìã∞ Ï∂úÌòÑ ÌõÑ, Ïó¨Îãπ Ï°∞Ïª§ ÎπºÎÇ¥Í∏∞');
                return jokerCall;
            }
            if (isGovernmentClose && round >= 5) {
                reasoning.push('Ï°∞Ïª§ÏΩú - Ïó¨Îãπ Í≥µÏïΩ ÏûÑÎ∞ï');
                return jokerCall;
            }
            if (round >= 7) {
                reasoning.push('Ï°∞Ïª§ÏΩú - ÌõÑÎ∞òÎ∂Ä');
                return jokerCall;
            }
        }
        // ‚òÖ‚òÖ‚òÖ ÎßàÏù¥Ìã∞ ÏÜåÏßÑ Ï†ÑÎûµ ‚òÖ‚òÖ‚òÖ
        if (!this.gameState.mightyUsed) {
            const mighty = this.gameState.contract.mighty;
            const mightySuit = mighty.suit;
            const myMightySuitCards = getCardsOfSuit(hand, mightySuit);

            if (myMightySuitCards.length > 0) {
                const remainingMightySuit = this.gameState.getRemainingCardsOfSuit(mightySuit);
                const otherMightySuitRemaining = remainingMightySuit.filter(c =>
                    !c.equals(mighty) && !myMightySuitCards.some(mc => mc.equals(c))
                );

                const masterVoidMightySuit = trackingSummary?.playerVoidSuits?.[masterIndex]
                    ? trackingSummary.playerVoidSuits[masterIndex].includes(mightySuit)
                    : false;

                const shouldForceMighty = (
                    round >= 3 && (
                        otherMightySuitRemaining.length <= 3 ||
                        masterVoidMightySuit ||
                        round >= 6
                    )
                );

                if (shouldForceMighty) {
                    const nonPointMightySuit = myMightySuitCards.filter(c => !c.isPointCard());

                    if (nonPointMightySuit.length > 0) {
                        reasoning.push(`ÎßàÏù¥Ìã∞ ÏÜåÏßÑ Ï†ÑÎûµ - ${SUIT_NAMES[mightySuit]} ÎπÑÏ†êÏàò Ïπ¥Îìú Î¶¨Îìú`);
                        return this.selectLowestCard(nonPointMightySuit);
                    }

                    const bossInMightySuit = myMightySuitCards.find(c => {
                        const analysis = this.gameState.getCardAnalysis(c);
                        return analysis.isBoss;
                    });

                    if (bossInMightySuit) {
                        reasoning.push(`ÎßàÏù¥Ìã∞ ÏÜåÏßÑ Ï†ÑÎûµ - ${SUIT_NAMES[mightySuit]} Î≥¥Ïä§Ïπ¥Îìú Î¶¨Îìú`);
                        return bossInMightySuit;
                    }

                    if (round >= 7 && myMightySuitCards.length > 0) {
                        reasoning.push(`ÎßàÏù¥Ìã∞ ÏÜåÏßÑ Ï†ÑÎûµ - ÌõÑÎ∞òÎ∂Ä ${SUIT_NAMES[mightySuit]} Î¶¨Îìú`);
                        return this.selectHighestCard(myMightySuitCards);
                    }
                }
            }
        }


        // ‚òÖ Í∏∞Î£®Îã§ ÏÜåÏßÑ Ï†ÑÎûµ
        if (giruda && !this.gameState.contract.isNoGiruda) {
            const myGirudaCards = getCardsOfSuit(hand, giruda);
            const masterVoidSuits = trackingSummary?.playerVoidSuits?.[masterIndex]
                ? new Set(trackingSummary.playerVoidSuits[masterIndex])
                : (this.gameState.playerVoidSuits.get(masterIndex) || new Set());
            const masterHasGiruda = !masterVoidSuits.has(giruda);

            if (myGirudaCards.length >= 3 && masterHasGiruda) {
                const girudaBoss = myGirudaCards.find(c => {
                    const analysis = this.gameState.getCardAnalysis(c);
                    return analysis.isBoss;
                });
                if (girudaBoss) {
                    reasoning.push('Í∏∞Î£®Îã§ ÏÜåÏßÑ Ï†ÑÎûµ - Í∏∞Î£®Îã§ Î≥¥Ïä§Ïπ¥Îìú Î¶¨Îìú');
                    return girudaBoss;
                }
                if (myGirudaCards.length >= 4) {
                    reasoning.push('Í∏∞Î£®Îã§ ÏÜåÏßÑ Ï†ÑÎûµ - ÎÇÆÏùÄ Í∏∞Î£®Îã§ Î¶¨Îìú');
                    return this.selectLowestCard(myGirudaCards);
                }
            }
        }

        if (this.shouldPlayMighty(hand, trickAnalysis, teamContext, true, round, trackingSummary)) {
            reasoning.push('ÎßàÏù¥Ìã∞ Î¶¨Îìú (ÏïºÎãπ Í≥µÍ≤©)'); return mighty;
        }

        if (isGovernmentClose) {
            reasoning.push('Ïó¨Îãπ Í≥µÏïΩ ÏûÑÎ∞ï - Í≥µÍ≤©Ï†Å ÌîåÎ†àÏù¥');
            const masterVoidSuits = trackingSummary?.playerVoidSuits?.[masterIndex]
                ? new Set(trackingSummary.playerVoidSuits[masterIndex])
                : (this.gameState.playerVoidSuits.get(masterIndex) || new Set());
            for (const suit of masterVoidSuits) {
                const suitCards = getCardsOfSuit(hand, suit);
                if (suitCards.length > 0) {
                    reasoning.push(`Ï£ºÍ≥µ ${SUIT_NAMES[suit]} ÏóÜÏùå - Í≥µÎûµ`);
                    return this.selectHighestCard(suitCards);
                }
            }
        }

        for (const suit of Object.values(SUITS)) {
            if (suit === giruda) continue;
            const suitCards = getCardsOfSuit(hand, suit);
            const ace = suitCards.find(c => c.rank === 'A');
            if (ace) { reasoning.push(`${SUIT_NAMES[suit]} A Î¶¨Îìú`); return ace; }
        }

        const nonGirudaCards = playableCards.filter(c => !c.isJoker && c.suit !== giruda);
        if (nonGirudaCards.length > 0) {
            reasoning.push('ÎπÑÍ∏∞Î£®Îã§ ÎÇÆÏùÄ Ïπ¥Îìú Î¶¨Îìú');
            return this.selectLowestCard(nonGirudaCards);
        }
        return this.selectLowestCard(playableCards);
    }

    // ===== Ïó¨Îãπ ÌåîÎ°úÏö∞ Ï†ÑÎûµ (ÌïµÏã¨ Î°úÏßÅ Ïú†ÏßÄ, Í∞ÑÍ≤∞Ìôî) =====
    governmentFollowStrategy(hand, trickAnalysis, teamContext, reasoning, trackingSummary = null) {
        const { playableCards, isGovernmentWinning, isOppositionWinning, isUncertain,
            canWin, cardsToWin, pointsInTrick, hasOppositionRemaining, hasGovernmentRemaining } = trickAnalysis;
        const round = this.gameState.round;
        const mighty = this.gameState.contract.mighty;
        const joker = hand.find(c => c.isJoker);
        const giruda = this.gameState.contract.giruda;
        const leadSuit = this.gameState.trick.leadSuit;
        const masterIndex = this.gameState.contract.master;
        const isFriend = teamContext.myRole === ROLES.FRIEND;

        const normalCards = playableCards.filter(c => !c.isJoker && !c.equals(mighty));
        const nonBossCards = normalCards.filter(c => { const a = this.gameState.getCardAnalysis(c); return !a.isBoss; });
        const nonBossPointCards = normalCards.filter(c => c.isPointCard() && !this.gameState.getCardAnalysis(c).isBoss);

        // Ï°∞Ïª§ÏΩú ÏÉÅÌô©
        if (this.gameState.trick.jokerCalled && (teamContext.myRole === ROLES.FRIEND || teamContext.myRole === ROLES.MASTER)) {
            reasoning.push('Ï°∞Ïª§ÏΩú ÏÉÅÌô©');
            if (hasCard(hand, mighty)) { reasoning.push('ÎßàÏù¥Ìã∞Î°ú ÏäπÎ¶¨'); return mighty; }
            if (canWin && cardsToWin.length > 0) {
                const normalWin = cardsToWin.filter(c => !c.isJoker);
                if (normalWin.length > 0) { reasoning.push('Ìä∏Î¶≠ ÌôïÎ≥¥'); return this.selectLowestCard(normalWin); }
            }
            return this.selectLowestNonPointCard(playableCards) || this.selectLowestCard(playableCards);
        }

        // Ï£ºÍ≥µ Ï°∞Ïª§ Î¶¨Îìú Ïãú ÏπúÍµ¨ Ï†ÑÎûµ
        const leadCard = this.gameState.trick.cards[0]?.card;
        const leadPlayer = this.gameState.trick.cards[0]?.player;
        if (leadCard?.isJoker && leadPlayer === masterIndex && isFriend) {
            reasoning.push('Ï£ºÍ≥µ Ï°∞Ïª§ Î¶¨Îìú - Ï†êÏàò Ïã§Ïñ¥Ï£ºÍ∏∞');
            const nonBoss = normalCards.filter(c => !this.gameState.getCardAnalysis(c).isBoss);
            const nbPoint = nonBoss.filter(c => c.isPointCard());
            if (nbPoint.length > 0) return this.selectLowestCard(nbPoint);
            if (nonBoss.length > 0) return this.selectLowestCard(nonBoss);
            if (normalCards.length > 0) return this.selectLowestCard(normalCards);
            return this.selectLowestCard(playableCards);
        }

        if (isGovernmentWinning) {
            const currentWinner = trickAnalysis.currentWinner;
            const winningPlay = this.gameState.trick.cards.find(p => p.player === currentWinner);
            const winningCard = winningPlay?.card;
            let isBoss = winningCard && !winningCard.isJoker && !winningCard.equals(mighty) && this.gameState.getCardAnalysis(winningCard).isBoss;
            let isStrong = winningCard && (winningCard.equals(mighty) || (winningCard.isJoker && round >= 2 && round <= 9) || isBoss);

            if (isFriend && currentWinner === masterIndex) {
                if (isStrong || !hasOppositionRemaining) {
                    reasoning.push('Ï£ºÍ≥µ ÏäπÎ¶¨ ÌôïÏã§ - ÎßàÏù¥Ìã∞/Ï°∞Ïª§ Î≥¥Ï°¥');
                    if (nonBossPointCards.length > 0) return this.selectLowestCard(nonBossPointCards);
                    if (nonBossCards.length > 0) return this.selectLowestCard(nonBossCards);
                    if (normalCards.length > 0) return this.selectLowestCard(normalCards);
                    return this.selectLowestCard(playableCards);
                }
                // Ï£ºÍ≥µ ÎπÑÎ≥¥Ïä§Ïπ¥Îìú + ÏïºÎãπ ÎÇ®Ïùå ‚Üí Ï†ÅÍ∑π Í∞úÏûÖ
                if (!isBoss && hasOppositionRemaining) {
                    if (hasCard(hand, mighty)) { reasoning.push('ÏπúÍµ¨ ÎßàÏù¥Ìã∞Î°ú ÌôïÎ≥¥'); return mighty; }
                    const mightyInTrick = this.gameState.trick.cards.some(p => p.card.equals(mighty));
                    if (joker && round >= 2 && round <= 9 && !mightyInTrick) { reasoning.push('ÏπúÍµ¨ Ï°∞Ïª§Î°ú ÌôïÎ≥¥'); return joker; }
                    if (canWin && cardsToWin.length > 0) {
                        const normalWin = cardsToWin.filter(c => !c.isJoker && !c.equals(mighty));
                        if (normalWin.length > 0) return this.selectLowestCard(normalWin);
                    }
                }
            }

            reasoning.push('ÏïÑÍµ∞ ÏäπÎ¶¨ - Î∞©Ïñ¥');
            const nonBossNonPoint = nonBossCards.filter(c => !c.isPointCard());
            if (nonBossNonPoint.length > 0) return this.selectLowestCard(nonBossNonPoint);
            if (nonBossCards.length > 0) return this.selectLowestCard(nonBossCards);
            return this.selectLowestNonPointCard(normalCards) || this.selectLowestCard(playableCards);
        }

        if (isOppositionWinning) {
            if (this.shouldPlayMighty(hand, trickAnalysis, teamContext, false, round, trackingSummary)) {
                reasoning.push('ÎßàÏù¥Ìã∞Î°ú ÌÉàÌôò'); return mighty;
            }
            const mightyInTrick = this.gameState.trick.cards.some(p => p.card.equals(mighty));
            if (joker && round >= 2 && round <= 9 && !mightyInTrick) {
                if (isFriend && leadPlayer === masterIndex) { reasoning.push('Ï£ºÍ≥µ Ïã†Ìò∏ - Ï°∞Ïª§ ÌÉàÌôò'); return joker; }
                const jd = this.shouldPlayJoker(hand, trickAnalysis, teamContext, false, round, trackingSummary);
                if (jd.shouldPlay) { reasoning.push('Ï°∞Ïª§Î°ú ÌÉàÌôò'); return joker; }
            }

            if (canWin && cardsToWin.length > 0) {
                if (pointsInTrick >= 2 || !hasGovernmentRemaining) {
                    reasoning.push('ÌÉàÌôò'); return this.selectLowestCard(cardsToWin);
                }
                if (hasGovernmentRemaining && pointsInTrick <= 1) {
                    reasoning.push('ÏïÑÍµ∞ÏóêÍ≤å ÏúÑÏûÑ');
                    return this.selectLowestNonPointCard(playableCards) || this.selectLowestCard(playableCards);
                }
                return this.selectLowestCard(cardsToWin);
            }

            if (hasGovernmentRemaining) {
                reasoning.push('ÏúÑÏûÑ');
                return this.selectLowestNonPointCard(playableCards) || this.selectLowestCard(playableCards);
            }
            reasoning.push('ÏÜêÏã§ ÏµúÏÜåÌôî');
            return this.selectLowestNonPointCard(playableCards) || this.selectLowestCard(playableCards);
        }

        // ÎØ∏ÌôïÏ†ï
        if (canWin && pointsInTrick >= 2) {
            reasoning.push('ÎØ∏ÌôïÏ†ï + Ï†êÏàò - ÌÉàÌôò');
            return this.selectLowestCard(cardsToWin);
        }
        reasoning.push('Í∏∞Î≥∏ - ÎÇÆÏùÄ Ïπ¥Îìú');
        return this.selectLowestCard(playableCards);
    }

    // ===== ÏïºÎãπ ÌåîÎ°úÏö∞ Ï†ÑÎûµ =====
    oppositionFollowStrategy(hand, trickAnalysis, teamContext, reasoning, trackingSummary = null) {
        const { playableCards, isGovernmentWinning, isOppositionWinning, isUncertain,
            canWin, cardsToWin, pointsInTrick, hasGovernmentRemaining, hasOppositionRemaining } = trickAnalysis;
        const round = this.gameState.round;
        const mighty = this.gameState.contract.mighty;
        const joker = hand.find(c => c.isJoker);
        const giruda = this.gameState.contract.giruda;

        const nonBossCards = playableCards.filter(c => {
            if (c.isJoker || c.equals(mighty)) return false;
            return !this.gameState.getCardAnalysis(c).isBoss;
        });
        const nonBossNonPoint = nonBossCards.filter(c => !c.isPointCard());

        // Ï°∞Ïª§ÏΩú ÏÉÅÌô©
        if (this.gameState.trick.jokerCalled) {
            reasoning.push('Ï°∞Ïª§ÏΩú ÏÉÅÌô©');
            if (canWin && cardsToWin.length > 0) {
                reasoning.push('ÌÉàÌôò ÏãúÎèÑ'); return this.selectLowestCard(cardsToWin);
            }
            return this.selectLowestNonPointCard(playableCards) || this.selectLowestCard(playableCards);
        }

        // Ï£ºÍ≥µ Ï°∞Ïª§ Î¶¨Îìú Ïãú
        const leadCard = this.gameState.trick.cards[0]?.card;
        const leadPlayer = this.gameState.trick.cards[0]?.player;
        const masterIndex = this.gameState.contract.master;
        if (leadCard?.isJoker && leadPlayer === masterIndex && round >= 2 && round <= 9) {
            reasoning.push('Ï£ºÍ≥µ Ï°∞Ïª§ Î¶¨Îìú - ÏÜêÏã§ ÏµúÏÜåÌôî');
            const nonPointCards = playableCards.filter(c => !c.isPointCard());
            if (nonPointCards.length > 0) return this.selectLowestCard(nonPointCards);
            return this.selectLowestCard(playableCards);
        }
        // ‚òÖ‚òÖ‚òÖ ÎßàÏù¥Ìã∞ ÏÜåÏßÑ ÌòëÎ†• Ï†ÑÎûµ ‚òÖ‚òÖ‚òÖ
        if (!this.gameState.mightyUsed) {
            const mighty = this.gameState.contract.mighty;
            const mightySuit = mighty.suit;
            const leadSuit = this.gameState.trick.leadSuit;

            if (leadSuit === mightySuit) {
                const leadPlayerIndex = this.gameState.trick.leadPlayer;
                const isLeaderOpposition = teamContext.oppositionPlayers.includes(leadPlayerIndex);

                if (isLeaderOpposition) {
                    reasoning.push('ÎßàÏù¥Ìã∞ ÏÜåÏßÑ ÌòëÎ†• - ÎÇÆÏùÄ Ïπ¥Îìú (Ï†êÏàò ÏïÑÎÅºÍ∏∞)');

                    const mightySuitCards = playableCards.filter(c => !c.isJoker && c.suit === mightySuit);
                    const nonPointMightySuit = mightySuitCards.filter(c => !c.isPointCard());

                    if (nonPointMightySuit.length > 0) {
                        return this.selectLowestCard(nonPointMightySuit);
                    }

                    if (mightySuitCards.length === 0) {
                        const safeCards = playableCards.filter(c =>
                            !c.isJoker && !c.isPointCard() && c.suit !== giruda
                        );
                        if (safeCards.length > 0) {
                            return this.selectLowestCard(safeCards);
                        }
                    }

                    return this.selectLowestNonPointCard(playableCards) || this.selectLowestCard(playableCards);
                }
            }
        }


        if (isOppositionWinning) {
            const currentWinner = trickAnalysis.currentWinner;
            const winningPlay = this.gameState.trick.cards.find(p => p.player === currentWinner);
            const winningCard = winningPlay?.card;
            let isWinBoss = winningCard && !winningCard.isJoker && !winningCard.equals(mighty) && this.gameState.getCardAnalysis(winningCard).isBoss;
            const isStrongWin = winningCard && ((winningCard.isJoker && round >= 2 && round <= 9) || (isWinBoss && winningCard.suit === giruda));

            if (isStrongWin || !hasGovernmentRemaining) {
                const nbPoint = nonBossCards.filter(c => c.isPointCard());
                if (nbPoint.length > 0) { reasoning.push('Ï†êÏàò Ïã§Ïñ¥Ï£ºÍ∏∞'); return this.selectLowestCard(nbPoint); }
                const pointCards = playableCards.filter(c => c.isPointCard() && !c.isJoker && !c.equals(mighty));
                if (pointCards.length > 0 && isStrongWin) { reasoning.push('Ï†êÏàò Ïã§Ïñ¥Ï£ºÍ∏∞'); return this.selectLowestCard(pointCards); }
            }
            reasoning.push('ÏïÑÍµ∞ ÏäπÎ¶¨ - ÎÇÆÏùÄ Ïπ¥Îìú');
            if (nonBossNonPoint.length > 0) return this.selectLowestCard(nonBossNonPoint);
            if (nonBossCards.length > 0) return this.selectLowestCard(nonBossCards);
            return this.selectLowestCard(playableCards);
        }

        if (isGovernmentWinning) {
            if (this.shouldPlayMighty(hand, trickAnalysis, teamContext, false, round, trackingSummary)) {
                reasoning.push('ÎßàÏù¥Ìã∞Î°ú ÌÉàÌôò'); return mighty;
            }

            const mightyInTrick = this.gameState.trick.cards.some(p => p.card.equals(mighty));
            const mightyPlayed = this.gameState.mightyUsed;
            if (joker && round >= 2 && round <= 9 && !mightyInTrick) {
                if (!mightyPlayed && hasGovernmentRemaining) {
                    if (pointsInTrick >= 4 || round >= 8) { reasoning.push('Ï°∞Ïª§Î°ú ÌÉàÌôò'); return joker; }
                } else {
                    const jd = this.shouldPlayJoker(hand, trickAnalysis, teamContext, false, round, trackingSummary);
                    if (jd.shouldPlay) { reasoning.push('Ï°∞Ïª§Î°ú ÌÉàÌôò'); return joker; }
                }
            }

            if (canWin && cardsToWin.length > 0) {
                if (!hasGovernmentRemaining || pointsInTrick >= 2) {
                    reasoning.push('ÌÉàÌôò'); return this.selectLowestCard(cardsToWin);
                }
                if (hasOppositionRemaining && pointsInTrick <= 1) {
                    const lowestWin = this.selectLowestCard(cardsToWin);
                    const str = lowestWin.isJoker ? 100 : RANK_VALUES[lowestWin.rank];
                    if (str >= 11) {
                        reasoning.push('ÎèôÎ£åÏóêÍ≤å ÏúÑÏûÑ');
                        if (nonBossNonPoint.length > 0) return this.selectLowestCard(nonBossNonPoint);
                        if (nonBossCards.length > 0) return this.selectLowestCard(nonBossCards);
                        return this.selectLowestNonPointCard(playableCards) || this.selectLowestCard(playableCards);
                    }
                }
                reasoning.push('ÌÉàÌôò'); return this.selectLowestCard(cardsToWin);
            }

            reasoning.push('ÏÜêÏã§ ÏµúÏÜåÌôî');
            if (nonBossNonPoint.length > 0) return this.selectLowestCard(nonBossNonPoint);
            if (nonBossCards.length > 0) return this.selectLowestCard(nonBossCards);
            return this.selectLowestNonPointCard(playableCards) || this.selectLowestCard(playableCards);
        }

        // ÎØ∏ÌôïÏ†ï
        if (canWin && pointsInTrick >= 1) {
            reasoning.push('ÎØ∏ÌôïÏ†ï + Ï†êÏàò - ÌÉàÌôò');
            return this.selectLowestCard(cardsToWin);
        }
        reasoning.push('Í∏∞Î≥∏ - ÎÇÆÏùÄ Ïπ¥Îìú');
        return this.selectLowestNonPointCard(playableCards) || this.selectLowestCard(playableCards);
    }

    // ===== Ï°∞Ïª§ ÏàòÌä∏ ÏÑ†Ïñ∏ =====
    selectJokerCallSuit(hand, teamContext) {
        const giruda = this.gameState.contract.giruda;
        const isGovernment = teamContext.myRole === ROLES.MASTER || teamContext.myRole === ROLES.FRIEND;
        const isNoGiruda = this.gameState.contract.isNoGiruda;

        if (isGovernment) {
            if (!isNoGiruda && giruda) {
                const remainingGiruda = this.gameState.getRemainingCardsOfSuit(giruda);
                const myGiruda = getCardsOfSuit(hand, giruda);
                const oppGiruda = remainingGiruda.filter(c => !myGiruda.some(mc => mc.equals(c)));
                if (oppGiruda.length > 0) return giruda;
            }
            const suitPointCounts = {};
            for (const suit of Object.values(SUITS)) {
                if (suit === giruda) continue;
                const remaining = this.gameState.getRemainingCardsOfSuit(suit);
                const pointCards = remaining.filter(c => c.isPointCard());
                const myCards = getCardsOfSuit(hand, suit);
                suitPointCounts[suit] = myCards.length === 0 ? pointCards.length + 5 : pointCards.length;
            }
            let bestSuit = null;
            let maxPoints = -1;
            for (const [suit, points] of Object.entries(suitPointCounts)) {
                if (points > maxPoints) { maxPoints = points; bestSuit = suit; }
            }
            if (bestSuit) return bestSuit;
        }

        if (!isGovernment) {
            const masterVoidSuits = this.gameState.playerVoidSuits.get(this.gameState.contract.master);
            if (masterVoidSuits && masterVoidSuits.size > 0) {
                for (const suit of masterVoidSuits) return suit;
            }
        }

        for (const suit of [SUITS.SPADE, SUITS.DIAMOND, SUITS.HEART, SUITS.CLUB]) {
            if (suit === giruda) continue;
            if (getCardsOfSuit(hand, suit).length === 0) return suit;
        }
        return giruda !== SUITS.SPADE ? SUITS.SPADE : SUITS.DIAMOND;
    }

    // ===== Ïú†Ìã∏Î¶¨Ìã∞ =====
    selectHighestCard(cards) {
        if (cards.length === 0) return null;
        return cards.reduce((h, c) => {
            if (c.isJoker) return h;
            if (!h || h.isJoker) return c;
            return RANK_VALUES[c.rank] > RANK_VALUES[h.rank] ? c : h;
        });
    }

    selectLowestCard(cards) {
        if (cards.length === 0) return null;
        return cards.reduce((l, c) => {
            if (c.isJoker) return (c.isJoker && !l) ? c : l;
            if (!l) return c;
            if (l.isJoker) return c;
            return RANK_VALUES[c.rank] < RANK_VALUES[l.rank] ? c : l;
        });
    }

    selectLowestNonPointCard(cards) {
        const nonPoint = cards.filter(c => !c.isPointCard());
        if (nonPoint.length === 0) return null;
        return this.selectLowestCard(nonPoint);
    }

    findLongestSuit(hand, excludeSuit = null) {
        let longest = null;
        let maxCount = 0;
        for (const suit of Object.values(SUITS)) {
            if (suit === excludeSuit) continue;
            const count = getCardsOfSuit(hand, suit).length;
            if (count > maxCount) { maxCount = count; longest = suit; }
        }
        return longest;
    }
}
// ========================================
// ===== ui.js =====
// ========================================

class UI {
    constructor(gameState, settings) {
        this.gameState = gameState;
        this.settings = settings;
        this.selectedCards = [];
        this.selectedBid = { value: null, suit: null };
        this.selectedFriend = { suit: null, rank: null };
        this.initializeEventListeners();
    }

    initializeEventListeners() {
        document.getElementById('test-mode-toggle').addEventListener('click', () => {
            this.settings.showAICards = !this.settings.showAICards;
            this.settings.showAILog = this.settings.showAICards;
            this.settings.highlightPlayable = this.settings.showAICards;
            this.updateTestModeButton();
            this.renderAll();
        });

        document.getElementById('settings-btn').addEventListener('click', () => this.showSettingsModal());
        document.getElementById('settings-close').addEventListener('click', () => this.hideSettingsModal());

        document.getElementById('setting-show-ai-cards').addEventListener('change', (e) => {
            this.settings.showAICards = e.target.checked; this.renderAll();
        });
        document.getElementById('setting-show-ai-log').addEventListener('change', (e) => {
            this.settings.showAILog = e.target.checked; this.renderAILog();
        });
        document.getElementById('setting-highlight-playable').addEventListener('change', (e) => {
            this.settings.highlightPlayable = e.target.checked; this.renderAll();
        });
        document.getElementById('setting-ai-speed').addEventListener('change', (e) => {
            this.settings.aiSpeed = parseInt(e.target.value);
        });
        document.getElementById('setting-use-sayeon').addEventListener('change', (e) => {
            this.settings.useSayeon = e.target.checked;
        });

        document.getElementById('log-toggle').addEventListener('click', () => {
            document.getElementById('ai-log-panel').classList.toggle('collapsed');
            const btn = document.getElementById('log-toggle');
            btn.textContent = btn.textContent === '‚ñº' ? '‚ñ∂' : '‚ñº';
        });

        document.getElementById('new-game-btn').addEventListener('click', () => {
            this.hideResultModal();
            if (this.onNewGame) this.onNewGame();
        });
        document.getElementById('end-game-btn').addEventListener('click', () => {
            this.hideResultModal();
            if (this.onEndGame) this.onEndGame();
        });

        // ‚òÖ ÌÇ§Î≥¥Îìú Îã®Ï∂ïÌÇ§
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                this.hideBiddingModal();
                this.hideFriendModal();
                this.hideExchangeModal();
                this.hideJokerCallModal();
                this.hideSettingsModal();
            }
            if ((e.key === 'p' || e.key === 'P') &&
                this.gameState.phase === PHASES.BIDDING &&
                this.gameState.currentTurn === 0 &&
                !document.getElementById('bidding-modal').classList.contains('hidden')) {
                this.passBid();
            }
            if (this.gameState.phase === PHASES.PLAYING && this.gameState.currentTurn === 0) {
                const keyNum = parseInt(e.key);
                if (!isNaN(keyNum)) {
                    const player = this.gameState.players[0];
                    const sortedHand = sortCards(player.hand, this.gameState.contract.giruda, this.gameState.contract.mighty);
                    const idx = keyNum === 0 ? 9 : keyNum - 1;
                    if (idx < sortedHand.length) this.onCardClick(sortedHand[idx]);
                }
            }
        });
    }

    updateTestModeButton() {
        const btn = document.getElementById('test-mode-toggle');
        if (this.settings.showAICards) {
            btn.classList.add('active');
            btn.textContent = 'üîß ÌÖåÏä§Ìä∏Î™®Îìú ON';
        } else {
            btn.classList.remove('active');
            btn.textContent = 'üîß ÌÖåÏä§Ìä∏Î™®Îìú OFF';
        }
    }

    renderAll() {
        this.renderInfoBar();
        this.renderPlayers();
        this.renderTrick();
        this.renderScoreProgress();
        this.renderAILog();
    }

    renderInfoBar() {
        document.getElementById('round-info').textContent = `ÎùºÏö¥Îìú: ${this.gameState.round || '-'}/10`;
        const contract = this.gameState.contract;
        if (contract.bidValue) {
            const suitSymbol = contract.isNoGiruda ? 'No' : (contract.giruda ? SUIT_SYMBOLS[contract.giruda] : '-');
            document.getElementById('contract-info').textContent = `Í≥µÏïΩ: ${contract.bidValue}${suitSymbol}`;
            document.getElementById('giruda-info').textContent = `Í∏∞Î£®Îã§: ${contract.isNoGiruda ? 'ÏóÜÏùå' : (contract.giruda ? SUIT_SYMBOLS[contract.giruda] : '-')}`;
            document.getElementById('mighty-info').textContent = `ÎßàÏù¥Ìã∞: ${contract.mighty?.toString() || '-'}`;
            document.getElementById('joker-call-info').textContent = `Ï°∞Ïª§ÏΩú: ${contract.jokerCall?.toString() || '-'}`;
            let friendText = '?';
            if (contract.isNoFriend) friendText = 'ÎÖ∏ÌîÑÎ†åÎìú';
            else if (contract.friendCard) {
                friendText = this.gameState.friendRevealed
                    ? `${contract.friendCard.toString()} (Í≥µÍ∞ú)`
                    : contract.friendCard.toString();
            }
            document.getElementById('friend-card-info').textContent = `ÏπúÍµ¨: ${friendText}`;
        } else {
            document.getElementById('contract-info').textContent = 'Í≥µÏïΩ: -';
            document.getElementById('giruda-info').textContent = 'Í∏∞Î£®Îã§: -';
            document.getElementById('mighty-info').textContent = 'ÎßàÏù¥Ìã∞: -';
            document.getElementById('joker-call-info').textContent = 'Ï°∞Ïª§ÏΩú: -';
            document.getElementById('friend-card-info').textContent = 'ÏπúÍµ¨: ?';
        }
    }

    renderPlayers() {
        for (let i = 0; i < GAME_CONFIG.PLAYER_COUNT; i++) this.renderPlayer(i);
    }

    renderPlayer(playerIndex) {
        const player = this.gameState.players[playerIndex];
        const element = document.getElementById(`player-${playerIndex}`);
        const handElement = element.querySelector('.player-hand');
        const roleElement = element.querySelector('.player-role');
        const scoreElement = element.querySelector('.player-score span');

        element.classList.toggle('active-turn', this.gameState.currentTurn === playerIndex);

        roleElement.textContent = player.getRoleText();
        roleElement.className = 'player-role';
        if (player.role === ROLES.MASTER) { roleElement.classList.add('master'); roleElement.textContent = 'Ï£ºÍ≥µ ‚òÖ'; }
        else if (player.role === ROLES.FRIEND) { roleElement.classList.add('friend'); roleElement.textContent = 'ÏπúÍµ¨ ‚óÜ'; }
        else if (player.role === ROLES.OPPOSITION) { roleElement.classList.add('opposition'); }

        scoreElement.textContent = player.getScore();
        handElement.innerHTML = '';

        let playableCards = [];
        if (this.gameState.phase === PHASES.PLAYING && this.gameState.currentTurn === playerIndex) {
            const mightyPlayedInTrick = this.gameState.trick.cards.some(
                p => p.card.equals(this.gameState.contract.mighty)
            );
            playableCards = getPlayableCards(player.hand, this.gameState.trick.leadSuit, this.gameState.round, {
                mighty: this.gameState.contract.mighty,
                jokerCalled: this.gameState.trick.jokerCalled,
                mightyPlayedInTrick
            });
        }

        const sortedHand = sortCards(player.hand, this.gameState.contract.giruda, this.gameState.contract.mighty);

        for (const card of sortedHand) {
            const cardEl = this.createCardElement(card, {
                faceUp: player.isHuman || this.settings.showAICards,
                isPlayable: playableCards.some(c => c.equals(card)),
                showHighlight: this.settings.highlightPlayable && !player.isHuman && this.gameState.currentTurn === playerIndex,
                isSpecial: this.isSpecialCard(card)
            });

            if (player.isHuman && this.gameState.phase === PHASES.PLAYING && this.gameState.currentTurn === 0) {
                const isPlayable = playableCards.some(c => c.equals(card));
                if (isPlayable) {
                    cardEl.classList.add('playable');
                    cardEl.addEventListener('click', () => this.onCardClick(card));
                } else {
                    cardEl.classList.add('dimmed');
                }
            }
            handElement.appendChild(cardEl);
        }
    }

    createCardElement(card, options = {}) {
        const { faceUp = true, isPlayable = false, showHighlight = false, isSpecial = false } = options;
        const cardEl = document.createElement('div');
        cardEl.className = 'card';

        if (faceUp) {
            cardEl.classList.add('face-up');
            if (card.isJoker) {
                cardEl.classList.add('joker');
                const img = document.createElement('img');
                img.src = JOKER_IMAGE; img.className = 'joker-image'; img.alt = 'Joker'; img.draggable = false;
                cardEl.appendChild(img);
            } else {
                const imageUrl = getCardImageUrl(card.suit, card.rank);
                if (imageUrl) {
                    const img = document.createElement('img');
                    img.src = imageUrl; img.className = 'card-image'; img.alt = `${card.rank} of ${card.suit}`; img.draggable = false;
                    cardEl.appendChild(img);
                }
            }
            if (isSpecial) {
                const label = this.getSpecialLabel(card);
                if (label) {
                    const labelEl = document.createElement('span');
                    labelEl.className = 'special-label'; labelEl.textContent = label;
                    cardEl.appendChild(labelEl);
                }
            }
            if (showHighlight && isPlayable) cardEl.classList.add('highlighted');
            else if (showHighlight && !isPlayable) cardEl.classList.add('dimmed');
        } else {
            cardEl.classList.add('face-down');
        }
        return cardEl;
    }

    isSpecialCard(card) {
        const { mighty, jokerCall, friendCard } = this.gameState.contract;
        return card.isJoker || (mighty && card.equals(mighty)) || (jokerCall && card.equals(jokerCall)) || (friendCard && card.equals(friendCard));
    }

    getSpecialLabel(card) {
        const { mighty, jokerCall, friendCard } = this.gameState.contract;
        if (mighty && card.equals(mighty)) return 'ÎßàÏù¥Ìã∞';
        if (card.isJoker) return 'Ï°∞Ïª§';
        if (jokerCall && card.equals(jokerCall)) return 'Ï°∞Ïª§ÏΩú';
        if (friendCard && card.equals(friendCard)) return 'ÏπúÍµ¨';
        return null;
    }

    // ‚òÖ Í∞úÏÑ†: Ïã§ÏãúÍ∞Ñ ÏäπÏûê ÌëúÏãú
    renderTrick() {
        const trickCards = this.gameState.trick.cards;
        const isComplete = trickCards.length === GAME_CONFIG.PLAYER_COUNT;
        const { winner, winningCard } = trickCards.length > 0
            ? this.gameState.determineTrickWinner()
            : { winner: null, winningCard: null };

        for (let i = 0; i < GAME_CONFIG.PLAYER_COUNT; i++) {
            const trickCardEl = document.querySelector(`.trick-card[data-player="${i}"]`);
            trickCardEl.innerHTML = '';
            trickCardEl.classList.remove('winner');
            const play = trickCards.find(p => p.player === i);
            if (play) {
                const cardEl = this.createCardElement(play.card, { faceUp: true });
                trickCardEl.appendChild(cardEl);
                if (winner === i) trickCardEl.classList.add('winner');
            }
        }

        const infoEl = document.getElementById('trick-info');
        if (trickCards.length > 0) {
            const leadSuit = this.gameState.trick.leadSuit;
            const points = trickCards.reduce((sum, p) => sum + (p.card.isPointCard() ? 1 : 0), 0);
            let infoText = `Î¶¨Îìú: ${SUIT_NAMES[leadSuit] || 'Ï°∞Ïª§'} | Ï†êÏàò: ${points}Ï†ê`;
            if (winner !== null && !isComplete) {
                infoText += ` | ÌòÑÏû¨ ÏäπÏûê: ${this.gameState.players[winner].name}`;
            }
            if (this.gameState.trick.jokerCalled) infoText += ' | üÉè Ï°∞Ïª§ÏΩú!';
            infoEl.textContent = infoText;
        } else {
            infoEl.textContent = '';
        }
    }

    clearTrick() {
        for (let i = 0; i < GAME_CONFIG.PLAYER_COUNT; i++) {
            const el = document.querySelector(`.trick-card[data-player="${i}"]`);
            el.innerHTML = ''; el.classList.remove('winner');
        }
        document.getElementById('trick-info').textContent = '';
    }

    // ‚òÖ ÌåÄÎ≥Ñ Ï†êÏàò ÏßÑÌñâ Î∞î
    renderScoreProgress() {
        const existing = document.getElementById('score-progress');
        if (existing) existing.remove();

        const contract = this.gameState.contract;
        if (!contract.bidValue || this.gameState.phase === PHASES.WAITING || this.gameState.phase === PHASES.BIDDING) return;

        const govScore = this.gameState.governmentScore;
        const oppScore = this.gameState.oppositionScore;
        const bidValue = contract.bidValue;
        const totalPoints = GAME_CONFIG.TOTAL_POINTS;
        const trickInfo = document.getElementById('trick-info');

        const div = document.createElement('div');
        div.id = 'score-progress';
        div.className = 'score-progress';
        div.innerHTML = `
            <span class="score-label government">Ïó¨Îãπ: ${govScore}/${bidValue}</span>
            <div class="score-bar">
                <div class="score-bar-fill government" style="width: ${(govScore / totalPoints) * 100}%"></div>
            </div>
            <div class="score-bar">
                <div class="score-bar-fill opposition" style="width: ${(oppScore / totalPoints) * 100}%"></div>
            </div>
            <span class="score-label opposition">ÏïºÎãπ: ${oppScore}</span>
        `;
        trickInfo.parentNode.insertBefore(div, trickInfo.nextSibling);
    }

    renderAILog() {
        const logContent = document.getElementById('ai-log-content');
        const panel = document.getElementById('ai-log-panel');
        if (!this.settings.showAILog) { panel.classList.add('hidden'); return; }
        panel.classList.remove('hidden');
        logContent.innerHTML = '';
        const logs = this.gameState.aiLogs.slice(-10).reverse();
        for (const log of logs) {
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            const header = document.createElement('div');
            header.className = 'log-header';
            header.textContent = `[R${log.round}] ${log.playerName}: ${log.action}`;
            entry.appendChild(header);
            if (log.reasoning && log.reasoning.length > 0) {
                const reasons = document.createElement('div');
                reasons.className = 'log-reasons';
                for (const reason of log.reasoning) {
                    const line = document.createElement('div');
                    line.className = 'reason-line'; line.textContent = `- ${reason}`;
                    reasons.appendChild(line);
                }
                entry.appendChild(reasons);
            }
            logContent.appendChild(entry);
        }
    }

    addAILog(playerIndex, action, reasoning = []) {
        const player = this.gameState.players[playerIndex];
        this.gameState.addAILog({ round: this.gameState.round, playerName: player.name, action, reasoning });
        this.renderAILog();
    }

    setActionButtons(buttons) {
        const container = document.getElementById('action-buttons');
        container.innerHTML = '';
        for (const btn of buttons) {
            const el = document.createElement('button');
            el.textContent = btn.text;
            el.className = btn.primary ? 'primary' : 'secondary';
            el.disabled = btn.disabled || false;
            el.addEventListener('click', btn.onClick);
            container.appendChild(el);
        }
    }

    clearActionButtons() {
        document.getElementById('action-buttons').innerHTML = '';
        document.getElementById('action-message').innerHTML = '';
    }

    setMessage(message) {
        document.getElementById('action-message').innerHTML = `<span>${message}</span>`;
    }

    clearMessage() { document.getElementById('action-message').innerHTML = ''; }

    // ===== ÎπÑÎî© Î™®Îã¨ =====
    showBiddingModal() {
        this.selectedBid = { value: null, suit: null };
        const currentBid = this.gameState.bidding.currentBid;
        document.getElementById('current-bid-display').textContent =
            currentBid ? `${currentBid.value}${currentBid.suit === 'none' ? 'No' : SUIT_SYMBOLS[currentBid.suit]}` : 'ÏóÜÏùå';

        const numbersContainer = document.getElementById('bid-numbers');
        numbersContainer.innerHTML = '';
        for (let i = GAME_CONFIG.MIN_BID; i <= GAME_CONFIG.MAX_BID; i++) {
            const btn = document.createElement('button');
            btn.textContent = i;
            btn.addEventListener('click', () => this.selectBidNumber(i));
            numbersContainer.appendChild(btn);
        }

        const suitsContainer = document.getElementById('bid-suits');
        suitsContainer.innerHTML = '';
        const suits = [
            { suit: SUITS.SPADE, symbol: '‚ô†', red: false },
            { suit: SUITS.DIAMOND, symbol: '‚óÜ', red: true },
            { suit: SUITS.HEART, symbol: '‚ô•', red: true },
            { suit: SUITS.CLUB, symbol: '‚ô£', red: false },
            { suit: 'none', symbol: 'No', red: false }
        ];
        for (const s of suits) {
            const btn = document.createElement('button');
            btn.textContent = s.symbol;
            if (s.red) btn.classList.add('red');
            btn.addEventListener('click', () => this.selectBidSuit(s.suit));
            suitsContainer.appendChild(btn);
        }

        document.getElementById('bid-preview').textContent = '-';
        document.getElementById('bid-submit').disabled = true;
        document.getElementById('bid-submit').onclick = () => this.submitBid();
        document.getElementById('bid-pass').onclick = () => this.passBid();
        document.getElementById('modal-overlay').classList.remove('hidden');
        document.getElementById('bidding-modal').classList.remove('hidden');
    }

    hideBiddingModal() {
        document.getElementById('modal-overlay').classList.add('hidden');
        document.getElementById('bidding-modal').classList.add('hidden');
    }

    selectBidNumber(value) {
        this.selectedBid.value = value;
        document.querySelectorAll('#bid-numbers button').forEach(btn => {
            btn.classList.toggle('selected', parseInt(btn.textContent) === value);
        });
        this.updateBidPreview();
    }

    selectBidSuit(suit) {
        this.selectedBid.suit = suit;
        const symbols = { [SUITS.SPADE]: '‚ô†', [SUITS.DIAMOND]: '‚óÜ', [SUITS.HEART]: '‚ô•', [SUITS.CLUB]: '‚ô£', 'none': 'No' };
        document.querySelectorAll('#bid-suits button').forEach(btn => {
            btn.classList.toggle('selected', btn.textContent === symbols[suit]);
        });
        this.updateBidPreview();
    }

    updateBidPreview() {
        const { value, suit } = this.selectedBid;
        const preview = document.getElementById('bid-preview');
        const submitBtn = document.getElementById('bid-submit');
        if (value && suit) {
            const symbol = suit === 'none' ? 'No' : SUIT_SYMBOLS[suit];
            preview.textContent = `${value}${symbol}`;
            const isValid = this.gameState.isValidBid(value, suit);
            submitBtn.disabled = !isValid;
            preview.style.color = isValid ? '#4CAF50' : '#f44336';
        } else {
            preview.textContent = '-'; submitBtn.disabled = true;
        }
    }

    submitBid() {
        if (this.onBidSubmit) this.onBidSubmit(this.selectedBid.value, this.selectedBid.suit);
        this.hideBiddingModal();
    }

    passBid() {
        if (this.onBidPass) this.onBidPass();
        this.hideBiddingModal();
    }

    // ===== ÏπúÍµ¨ ÏÑ†Ïñ∏ Î™®Îã¨ =====
    showFriendModal() {
        this.selectedFriend = { suit: null, rank: null };
        const mighty = this.gameState.contract.mighty;
        const mightyDisplay = document.getElementById('mighty-card-display');
        if (mightyDisplay && mighty) {
            mightyDisplay.textContent = mighty.toString();
            mightyDisplay.className = 'btn-card' + (mighty.isRed() ? ' red' : '');
        }

        document.getElementById('friend-mighty').onclick = () => {
            if (this.onFriendDeclare) this.onFriendDeclare(this.gameState.contract.mighty);
            this.hideFriendModal();
        };
        document.getElementById('friend-joker').onclick = () => {
            if (this.onFriendDeclare) this.onFriendDeclare(Card.createJoker());
            this.hideFriendModal();
        };

        const suitsContainer = document.getElementById('friend-suit-buttons');
        suitsContainer.innerHTML = '';
        const suits = [
            { suit: SUITS.SPADE, symbol: '‚ô†', red: false },
            { suit: SUITS.DIAMOND, symbol: '‚óÜ', red: true },
            { suit: SUITS.HEART, symbol: '‚ô•', red: true },
            { suit: SUITS.CLUB, symbol: '‚ô£', red: false }
        ];
        for (const s of suits) {
            const btn = document.createElement('button');
            btn.textContent = s.symbol;
            btn.style.cssText = `font-size:24px;width:50px;height:50px;padding:0;border:2px solid #444;background:#333;color:${s.red ? '#d32f2f' : 'white'};border-radius:5px;cursor:pointer;`;
            btn.addEventListener('click', () => this.selectFriendSuit(s.suit));
            suitsContainer.appendChild(btn);
        }

        const ranksContainer = document.getElementById('friend-rank-buttons');
        ranksContainer.innerHTML = '';
        for (const rank of RANKS) {
            const btn = document.createElement('button');
            btn.textContent = rank;
            btn.addEventListener('click', () => this.selectFriendRank(rank));
            ranksContainer.appendChild(btn);
        }

        document.getElementById('friend-preview').textContent = '-';
        document.getElementById('friend-confirm').onclick = () => this.confirmFriend();
        document.getElementById('no-friend').onclick = () => this.declareNoFriend();
        document.getElementById('modal-overlay').classList.remove('hidden');
        document.getElementById('friend-modal').classList.remove('hidden');
    }

    hideFriendModal() {
        document.getElementById('modal-overlay').classList.add('hidden');
        document.getElementById('friend-modal').classList.add('hidden');
    }

    selectFriendSuit(suit) {
        this.selectedFriend.suit = suit;
        const symbols = { [SUITS.SPADE]: '‚ô†', [SUITS.DIAMOND]: '‚óÜ', [SUITS.HEART]: '‚ô•', [SUITS.CLUB]: '‚ô£' };
        document.querySelectorAll('#friend-suit-buttons button').forEach(btn => {
            const isSel = btn.textContent === symbols[suit];
            btn.style.background = isSel ? '#4CAF50' : '#333';
            btn.style.borderColor = isSel ? '#4CAF50' : '#444';
        });
        this.updateFriendPreview();
    }

    selectFriendRank(rank) {
        this.selectedFriend.rank = rank;
        document.querySelectorAll('#friend-rank-buttons button').forEach(btn => {
            btn.classList.toggle('selected', btn.textContent === rank);
        });
        this.updateFriendPreview();
    }

    updateFriendPreview() {
        const { suit, rank } = this.selectedFriend;
        const preview = document.getElementById('friend-preview');
        if (rank === 'JOKER') preview.textContent = 'JOKER';
        else if (suit && rank) preview.textContent = `${SUIT_SYMBOLS[suit]}${rank}`;
        else preview.textContent = '-';
    }

    confirmFriend() {
        const { suit, rank } = this.selectedFriend;
        let card = null;
        if (rank === 'JOKER') card = Card.createJoker();
        else if (suit && rank) card = new Card(suit, rank);
        if (card && this.onFriendDeclare) this.onFriendDeclare(card);
        this.hideFriendModal();
    }

    declareNoFriend() {
        if (this.onFriendDeclare) this.onFriendDeclare(null);
        this.hideFriendModal();
    }

    // ===== Ïπ¥Îìú ÍµêÌôò Î™®Îã¨ =====
    showExchangeModal() {
        this.selectedCards = [];
        this.newGiruda = null;
        this.isNoGiruda = false;
        this.isSolino = false;

        const player = this.gameState.players[this.gameState.contract.master];
        const handContainer = document.getElementById('exchange-hand');
        handContainer.innerHTML = '';
        const sortedHand = sortCards(player.hand, this.gameState.contract.giruda, this.gameState.contract.mighty);

        for (const card of sortedHand) {
            const cardEl = this.createCardElement(card, { faceUp: true, isSpecial: this.isSpecialCard(card) });
            cardEl.style.cursor = 'pointer';
            cardEl.addEventListener('click', () => this.toggleExchangeCard(card, cardEl));
            handContainer.appendChild(cardEl);
        }

        document.getElementById('exchange-count').textContent = '0';
        document.getElementById('exchange-confirm').disabled = true;
        document.getElementById('exchange-confirm').onclick = () => this.confirmExchange();
        this.setupGirudaChangeUI();
        document.getElementById('modal-overlay').classList.remove('hidden');
        document.getElementById('exchange-modal').classList.remove('hidden');
    }

    setupGirudaChangeUI() {
        const currentGiruda = this.gameState.contract.giruda;
        const currentBid = this.gameState.contract.bidValue;
        const isMaxBid = currentBid >= GAME_CONFIG.MAX_BID;

        this.newGiruda = null;
        this.isNoGiruda = false;
        this.isSolino = false;

        const currentGirudaName = currentGiruda ? SUIT_NAMES[currentGiruda] : 'ÎÖ∏Í∏∞Î£®Îã§';
        const currentGirudaSymbol = currentGiruda ? SUIT_SYMBOLS[currentGiruda] : 'ÏóÜÏùå';

        document.getElementById('giruda-current-info').innerHTML =
            `ÌòÑÏû¨: <span class="current-giruda">${currentGirudaSymbol} ${currentGirudaName}</span> / Í≥µÏïΩ: <span class="current-bid">${currentBid}</span>`;

        if (isMaxBid) {
            document.getElementById('giruda-change-cost').innerHTML =
                '<span style="color: #4CAF50;">‚òÖ Í≥µÏïΩ 20 ÌäπÏ†Ñ: Î¨¥Î£å Î≥ÄÍ≤Ω / ÎÖ∏Í∏∞Î£®Îã§ / ÎÖ∏ÌîÑÎ†åÎìú Í∞ÄÎä•</span>';
        } else {
            const newBid = Math.min(currentBid + 2, GAME_CONFIG.MAX_BID);
            document.getElementById('giruda-change-cost').textContent = `Î≥ÄÍ≤Ω Ïãú Í≥µÏïΩ +2 ‚Üí ${newBid}`;
        }

        const buttonsContainer = document.getElementById('giruda-change-buttons');
        if (!buttonsContainer) return;
        buttonsContainer.innerHTML = '';

        const suits = [
            { suit: SUITS.SPADE, symbol: '‚ô†', isRed: false },
            { suit: SUITS.DIAMOND, symbol: '‚óÜ', isRed: true },
            { suit: SUITS.HEART, symbol: '‚ô•', isRed: true },
            { suit: SUITS.CLUB, symbol: '‚ô£', isRed: false }
        ];

        for (const { suit, symbol, isRed } of suits) {
            const btn = document.createElement('button');
            btn.className = `giruda-btn ${isRed ? 'red' : 'black'}`;
            btn.textContent = symbol;
            if (suit === currentGiruda && !isMaxBid) {
                btn.classList.add('current'); btn.disabled = true;
            } else {
                if (suit === currentGiruda) btn.classList.add('current');
                btn.addEventListener('click', () => this.selectNewGiruda(suit, btn));
            }
            buttonsContainer.appendChild(btn);
        }

        if (isMaxBid) {
            const noGirudaBtn = document.createElement('button');
            noGirudaBtn.className = 'giruda-btn no-giruda';
            noGirudaBtn.textContent = 'No';
            noGirudaBtn.addEventListener('click', () => this.selectNoGiruda(noGirudaBtn));
            buttonsContainer.appendChild(noGirudaBtn);

            const separator = document.createElement('span');
            separator.className = 'giruda-separator'; separator.textContent = '|';
            buttonsContainer.appendChild(separator);

            const solinoLabel = document.createElement('label');
            solinoLabel.className = 'solino-option';
            solinoLabel.innerHTML = `<input type="checkbox" id="solino-check"><span>ÎÖ∏ÌîÑÎ†åÎìú (ÏÜîÎ¶¨ÎÖ∏)</span>`;
            buttonsContainer.appendChild(solinoLabel);

            setTimeout(() => {
                const cb = document.getElementById('solino-check');
                if (cb) cb.addEventListener('change', (e) => { this.isSolino = e.target.checked; this.updateExchangeConfirmButton(); });
            }, 0);
        }
    }

    selectNoGiruda(btnEl) {
        document.querySelectorAll('#giruda-change-buttons .giruda-btn').forEach(btn => btn.classList.remove('selected'));
        if (this.isNoGiruda) { this.isNoGiruda = false; this.newGiruda = null; }
        else { this.isNoGiruda = true; this.newGiruda = null; btnEl.classList.add('selected'); }
        this.updateExchangeConfirmButton();
    }

    selectNewGiruda(suit, btnEl) {
        document.querySelectorAll('#giruda-change-buttons .giruda-btn').forEach(btn => btn.classList.remove('selected'));
        this.isNoGiruda = false;
        if (this.newGiruda === suit) { this.newGiruda = null; this.updateExchangeConfirmButton(); return; }
        this.newGiruda = suit; btnEl.classList.add('selected');
        this.updateExchangeConfirmButton();
    }

    updateExchangeConfirmButton() {
        const btn = document.getElementById('exchange-confirm');
        btn.disabled = this.selectedCards.length !== 3;
        const currentBid = this.gameState.contract.bidValue;
        const isMaxBid = currentBid >= GAME_CONFIG.MAX_BID;
        let changes = [];
        if (this.isNoGiruda) changes.push('ÎÖ∏Í∏∞Î£®Îã§');
        else if (this.newGiruda && this.newGiruda !== this.gameState.contract.giruda) {
            if (isMaxBid) changes.push(`Í∏∞Î£®Îã§ ‚Üí ${SUIT_SYMBOLS[this.newGiruda]}`);
            else changes.push(`Í∏∞Î£®Îã§ ‚Üí ${SUIT_SYMBOLS[this.newGiruda]} (Í≥µÏïΩ ${Math.min(currentBid + 2, GAME_CONFIG.MAX_BID)})`);
        }
        if (this.isSolino) changes.push('ÎÖ∏ÌîÑÎ†åÎìú');
        btn.textContent = changes.length > 0 ? `ÌôïÏù∏ (${changes.join(', ')})` : 'ÌôïÏù∏';
    }

    hideExchangeModal() {
        document.getElementById('modal-overlay').classList.add('hidden');
        document.getElementById('exchange-modal').classList.add('hidden');
    }

    toggleExchangeCard(card, cardEl) {
        const index = this.selectedCards.findIndex(c => c.equals(card));
        if (index >= 0) { this.selectedCards.splice(index, 1); cardEl.classList.remove('selected'); }
        else if (this.selectedCards.length < 3) { this.selectedCards.push(card); cardEl.classList.add('selected'); }
        document.getElementById('exchange-count').textContent = this.selectedCards.length;
        this.updateExchangeConfirmButton();
    }

    confirmExchange() {
        if (this.selectedCards.length === 3 && this.onExchangeConfirm) {
            this.onExchangeConfirm(this.selectedCards, { newGiruda: this.newGiruda, isNoGiruda: this.isNoGiruda, isSolino: this.isSolino });
        }
        this.hideExchangeModal();
    }

    // ===== Ï°∞Ïª§ ÏàòÌä∏ Î™®Îã¨ =====
    showJokerCallModal() {
        const container = document.getElementById('joker-suit-buttons');
        container.innerHTML = '';
        const suits = [
            { suit: SUITS.SPADE, symbol: '‚ô†', red: false },
            { suit: SUITS.DIAMOND, symbol: '‚óÜ', red: true },
            { suit: SUITS.HEART, symbol: '‚ô•', red: true },
            { suit: SUITS.CLUB, symbol: '‚ô£', red: false }
        ];
        for (const s of suits) {
            const btn = document.createElement('button');
            btn.textContent = s.symbol;
            if (s.red) btn.classList.add('red');
            btn.addEventListener('click', () => {
                if (this.onJokerSuitSelect) this.onJokerSuitSelect(s.suit);
                this.hideJokerCallModal();
            });
            container.appendChild(btn);
        }
        document.getElementById('modal-overlay').classList.remove('hidden');
        document.getElementById('joker-call-modal').classList.remove('hidden');
    }

    hideJokerCallModal() {
        document.getElementById('modal-overlay').classList.add('hidden');
        document.getElementById('joker-call-modal').classList.add('hidden');
    }

    // ===== Í≤∞Í≥º Î™®Îã¨ =====
    showResultModal(result, gameHistory = []) {
        const title = document.getElementById('result-title');
        const content = document.getElementById('result-content');
        const userResult = result.results.find(r => r.player === 0);
        const userWon = userResult && userResult.change > 0;

        title.textContent = userWon ? 'üéâ ÏäπÎ¶¨! üéâ' : 'üò¢ Ìå®Î∞∞ üò¢';
        title.className = userWon ? 'win' : 'lose';

        let html = '<div class="result-summary">';
        html += `<p>${result.winner === 'government' ? 'Ïó¨Îãπ' : 'ÏïºÎãπ'} ÏäπÎ¶¨!</p>`;
        if (result.isBackrun) html += '<p style="color: #FFD700;">Î∞±Îü∞ Îã¨ÏÑ±!</p>';
        html += `<p>Ïó¨Îãπ Ï†êÏàò: ${this.gameState.governmentScore}Ï†ê / Í≥µÏïΩ: ${this.gameState.contract.bidValue}Ï†ê</p>`;
        html += '</div>';

        html += '<div class="result-scores">';
        html += '<div class="result-header"><span>ÌîåÎ†àÏù¥Ïñ¥</span><span>ÌöçÎìù</span><span>Î≥ÄÎèô</span></div>';
        for (const r of result.results) {
            const player = this.gameState.players[r.player];
            const earnedPoints = player.getScore();
            const changeClass = r.change >= 0 ? 'positive' : 'negative';
            const changeText = r.change >= 0 ? `+${r.change}` : `${r.change}`;
            html += `<div class="score-row">
                <span class="player-name">${player.name} (${player.getRoleText() || 'ÏïºÎãπ'})</span>
                <span class="earned-points">${earnedPoints}Ï†ê</span>
                <span class="score-change ${changeClass}">${changeText}Ï†ê</span>
            </div>`;
        }
        html += '</div>';

        const contract = this.gameState.contract;
        const friendContrib = this.gameState.friendContribution;
        if (!contract.isNoFriend && !contract.isSolino && contract.friend !== null) {
            const friendPlayer = this.gameState.players[contract.friend];
            const friendName = friendPlayer ? friendPlayer.name : 'ÏπúÍµ¨';
            html += '<div class="friend-contribution">';
            html += `<div class="contribution-header">ü§ù ÏπúÍµ¨(${friendName}) Í≥µÌóåÎèÑ</div>`;
            html += '<div class="contribution-details">';
            html += `<div class="contribution-item"><span class="contribution-label">Ï±ÖÏûÑÏßÑ Ìä∏Î¶≠</span><span class="contribution-value">${friendContrib.tricksWon}Ìöå</span></div>`;
            html += `<div class="contribution-item"><span class="contribution-label">ÌôïÎ≥¥Ìïú Ï†êÏàò</span><span class="contribution-value">${friendContrib.pointsSecured}Ï†ê</span></div>`;
            const specialCards = [];
            if (friendContrib.mightyUsed) specialCards.push('ÎßàÏù¥Ìã∞');
            if (friendContrib.jokerUsed) specialCards.push('Ï°∞Ïª§');
            if (specialCards.length > 0) {
                html += `<div class="contribution-item"><span class="contribution-label">ÏÇ¨Ïö©Ìïú ÌäπÏàòÏπ¥Îìú</span><span class="contribution-value special">${specialCards.join(', ')}</span></div>`;
            }
            html += '</div></div>';
        }

        // Í≤åÏûÑ Í∏∞Î°ù
        if (gameHistory && gameHistory.length > 0) {
            html += '<div class="game-history"><div class="history-header">üìä Í≤åÏûÑ Í∏∞Î°ù</div>';
            html += '<div class="history-table-wrapper"><table class="history-table">';
            html += '<thead><tr><th>Í≤åÏûÑ</th><th>Í≥µÏïΩ</th><th>Í≤∞Í≥º</th>';
            for (let i = 0; i < 5; i++) { html += `<th>${i === 0 ? 'ÎÇò' : `AI${i}`}</th>`; }
            html += '</tr></thead><tbody>';
            for (const game of gameHistory) {
                const girudaSymbol = game.giruda ? SUIT_SYMBOLS[game.giruda] : 'No';
                const winnerText = game.winner === 'government' ? 'Ïó¨Îãπ' : 'ÏïºÎãπ';
                const winnerClass = game.winner === 'government' ? 'gov-win' : 'opp-win';
                html += `<tr><td>${game.gameNumber}</td><td>${game.bidValue}${girudaSymbol}</td><td class="${winnerClass}">${winnerText}${game.isBackrun ? '(Î∞±)' : ''}</td>`;
                for (let i = 0; i < 5; i++) {
                    const change = game.results.find(r => r.player === i)?.change || 0;
                    const cls = change >= 0 ? 'positive' : 'negative';
                    const txt = change >= 0 ? `+${change}` : `${change}`;
                    const role = game.master === i ? '‚òÖ' : (game.friend === i ? '‚òÜ' : '');
                    html += `<td class="${cls}">${role}${txt}</td>`;
                }
                html += '</tr>';
            }
            html += '</tbody><tfoot><tr><td colspan="3"><strong>ÎàÑÏ†Å Ìï©Í≥Ñ</strong></td>';
            const last = gameHistory[gameHistory.length - 1];
            for (let i = 0; i < 5; i++) {
                const total = last.cumulativeScores[i];
                const cls = total >= 0 ? 'positive' : 'negative';
                const txt = total >= 0 ? `+${total}` : `${total}`;
                html += `<td class="${cls}"><strong>${txt}</strong></td>`;
            }
            html += '</tr></tfoot></table></div>';
            html += '<div class="history-legend"><span>‚òÖ Ï£ºÍ≥µ</span><span>‚òÜ ÏπúÍµ¨</span></div></div>';
        }

        content.innerHTML = html;
        document.getElementById('modal-overlay').classList.remove('hidden');
        document.getElementById('result-modal').classList.remove('hidden');
    }

    hideResultModal() {
        document.getElementById('modal-overlay').classList.add('hidden');
        document.getElementById('result-modal').classList.add('hidden');
    }

    showSettingsModal() {
        document.getElementById('setting-show-ai-cards').checked = this.settings.showAICards;
        document.getElementById('setting-show-ai-log').checked = this.settings.showAILog;
        document.getElementById('setting-highlight-playable').checked = this.settings.highlightPlayable;
        document.getElementById('setting-ai-speed').value = this.settings.aiSpeed;
        document.getElementById('setting-use-sayeon').checked = this.settings.useSayeon;
        document.getElementById('modal-overlay').classList.remove('hidden');
        document.getElementById('settings-modal').classList.remove('hidden');
    }

    hideSettingsModal() {
        document.getElementById('modal-overlay').classList.add('hidden');
        document.getElementById('settings-modal').classList.add('hidden');
    }

    onCardClick(card) { if (this.onCardSelect) this.onCardSelect(card); }

    setCallbacks(callbacks) {
        this.onBidSubmit = callbacks.onBidSubmit;
        this.onBidPass = callbacks.onBidPass;
        this.onFriendDeclare = callbacks.onFriendDeclare;
        this.onExchangeConfirm = callbacks.onExchangeConfirm;
        this.onCardSelect = callbacks.onCardSelect;
        this.onJokerSuitSelect = callbacks.onJokerSuitSelect;
        this.onNewGame = callbacks.onNewGame;
        this.onEndGame = callbacks.onEndGame;
    }
}

// ========================================
// ===== main.js =====
// ========================================

class GameController {
    constructor() {
        this.gameState = new GameState();
        this.settings = { ...DEFAULT_SETTINGS };
        this.ui = new UI(this.gameState, this.settings);
        this.ai = new AI(this.gameState, this.settings);
        this.pendingCard = null;
        this.isProcessing = false;
        this.gameHistory = [];
        this.setupCallbacks();
        this.startNewGame();
    }

    setupCallbacks() {
        this.ui.setCallbacks({
            onBidSubmit: (value, suit) => this.handleBid(value, suit),
            onBidPass: () => this.handlePass(),
            onFriendDeclare: (card) => this.handleFriendDeclare(card),
            onExchangeConfirm: (cards, options) => this.handleExchange(cards, options),
            onCardSelect: (card) => this.handleCardSelect(card),
            onJokerSuitSelect: (suit) => this.handleJokerSuit(suit),
            onNewGame: () => this.startNewGame(),
            onEndGame: () => this.endSession()
        });
    }

    async startNewGame() {
        this.gameState.reset();
        this.isProcessing = false;
        this.pendingCard = null;
        this.ui.clearTrick();
        this.ui.clearActionButtons();
        this.ui.renderAll();
        await this.delay(500);
        await this.dealCards();
    }

    async dealCards() {
        this.gameState.phase = PHASES.DEALING;
        this.ui.setMessage('Ïπ¥ÎìúÎ•º Î∞∞Î∂ÑÌïòÎäî Ï§ë...');
        const deck = new Deck();
        deck.shuffle();
        this.gameState.floorCards = deck.deal(GAME_CONFIG.FLOOR_CARDS);
        for (let i = 0; i < GAME_CONFIG.PLAYER_COUNT; i++) {
            const playerIndex = (this.gameState.dealer + 1 + i) % GAME_CONFIG.PLAYER_COUNT;
            const cards = deck.deal(GAME_CONFIG.CARDS_PER_PLAYER);
            this.gameState.players[playerIndex].receiveCards(cards);
            this.gameState.players[playerIndex].sortHand();
        }
        this.ui.renderAll();
        await this.delay(500);
        await this.checkPoolRequest();
    }

    async checkPoolRequest() {
        this.gameState.phase = PHASES.DEAL_CHECK;
        const baseMighty = new Card(SUITS.SPADE, 'A');
        const eligiblePlayers = [];
        for (let i = 0; i < GAME_CONFIG.PLAYER_COUNT; i++) {
            const hand = this.gameState.players[i].hand;
            const eligibility = checkPoolRequestEligibility(hand, baseMighty);
            if (eligibility.eligible) eligiblePlayers.push({ playerIndex: i, eligibility });
        }
        if (eligiblePlayers.length === 0) { await this.startBidding(); return; }

        const userEligible = eligiblePlayers.find(p => p.playerIndex === 0);
        if (userEligible) {
            this.ui.setMessage(`ÌíÄÏã†Ï≤≠ Í∞ÄÎä•! (${userEligible.eligibility.reason})`);
            this.ui.setActionButtons([
                { text: 'ÌíÄÏã†Ï≤≠', primary: true, onClick: () => this.handlePoolRequest(0) },
                { text: 'ÏßÑÌñâ', primary: false, onClick: () => this.continueAfterPoolCheck(eligiblePlayers.filter(p => p.playerIndex !== 0)) }
            ]);
        } else {
            await this.processAIPoolRequests(eligiblePlayers);
        }
    }

    async handlePoolRequest(playerIndex) {
        const playerName = playerIndex === 0 ? 'ÎãπÏã†' : `AI-${playerIndex}`;
        this.ui.setMessage(`${playerName}Ïù¥(Í∞Ä) ÌíÄÏã†Ï≤≠ÏùÑ ÌñàÏäµÎãàÎã§!`);
        this.ui.clearActionButtons();
        await this.delay(1000);
        await this.askForBid20Accept(playerIndex);
    }

    async processAIPoolRequests(eligiblePlayers) {
        for (const { playerIndex, eligibility } of eligiblePlayers) {
            if (eligibility.eligible) {
                this.ui.setMessage(`AI-${playerIndex}Ïù¥(Í∞Ä) ÌíÄÏã†Ï≤≠ÏùÑ ÌñàÏäµÎãàÎã§! (${eligibility.reason})`);
                await this.delay(1500);
                await this.askForBid20Accept(playerIndex);
                return;
            }
        }
        await this.startBidding();
    }

    async continueAfterPoolCheck(remaining) {
        this.ui.clearActionButtons();
        if (remaining.length > 0) await this.processAIPoolRequests(remaining);
        else await this.startBidding();
    }

    async askForBid20Accept(poolRequesterIndex) {
        this.gameState.poolRequester = poolRequesterIndex;
        if (poolRequesterIndex !== 0) {
            this.ui.setMessage('ÌíÄÏã†Ï≤≠Ïù¥ ÏûàÏäµÎãàÎã§. 20ÏúºÎ°ú Ï£ºÍ≥µÏùÑ ÌïòÏãúÍ≤†ÏäµÎãàÍπå?');
            this.ui.setActionButtons([
                { text: '20ÏúºÎ°ú ÏßÑÌñâ', primary: true, onClick: () => this.acceptBid20(0) },
                { text: 'Ìå®Ïä§', primary: false, onClick: () => this.checkAIBid20Accept(poolRequesterIndex) }
            ]);
        } else {
            await this.checkAIBid20Accept(poolRequesterIndex);
        }
    }

    async checkAIBid20Accept(poolRequesterIndex) {
        this.ui.clearActionButtons();
        for (let i = 1; i < GAME_CONFIG.PLAYER_COUNT; i++) {
            if (i === poolRequesterIndex) continue;
            const hand = this.gameState.players[i].hand;
            if (this.shouldAIAcceptBid20(hand)) {
                this.ui.setMessage(`AI-${i}Ïù¥(Í∞Ä) 20ÏúºÎ°ú ÏßÑÌñâÌïòÍ≤†Îã§Í≥† ÏÑ†Ïñ∏ÌñàÏäµÎãàÎã§!`);
                await this.delay(1500);
                await this.forceSetMasterWithBid20(i);
                return;
            } else {
                this.ui.setMessage(`AI-${i}: Ìå®Ïä§`);
                await this.delay(800);
            }
        }
        this.ui.setMessage('ÏïÑÎ¨¥ÎèÑ 20ÏúºÎ°ú ÏßÑÌñâÌïòÏßÄ ÏïäÏïÑ ÌåêÏùÑ Î¨¥Ìö®Î°ú Ìï©ÎãàÎã§.');
        await this.delay(2000);
        this.startNewGame();
    }

    acceptBid20(playerIndex) {
        this.ui.clearActionButtons();
        this.ui.setMessage('20ÏúºÎ°ú Ï£ºÍ≥µÏùÑ ÏßÑÌñâÌï©ÎãàÎã§!');
        setTimeout(async () => { await this.forceSetMasterWithBid20(playerIndex); }, 1000);
    }

    async forceSetMasterWithBid20(playerIndex) {
        const defaultGiruda = SUITS.SPADE;
        this.gameState.bidding.currentBid = { player: playerIndex, value: 20, suit: defaultGiruda };
        this.gameState.bidding.history.push({ player: playerIndex, value: 20, suit: defaultGiruda, type: 'bid' });
        this.gameState.contract.master = playerIndex;
        this.gameState.contract.bidValue = 20;
        this.gameState.contract.giruda = defaultGiruda;
        this.gameState.contract.isNoGiruda = false;
        this.gameState.contract.mighty = getMighty(defaultGiruda);
        this.gameState.contract.jokerCall = getJokerCall(defaultGiruda);
        this.gameState.players[playerIndex].setRole(ROLES.MASTER);
        const playerName = playerIndex === 0 ? 'ÎãπÏã†' : `AI-${playerIndex}`;
        this.ui.setMessage(`${playerName}Ïù¥(Í∞Ä) 20${SUIT_SYMBOLS[defaultGiruda]}Î°ú Ï£ºÍ≥µÏù¥ ÎêòÏóàÏäµÎãàÎã§!`);
        this.ui.renderAll();
        await this.delay(1500);
        await this.endBidding();
    }

    shouldAIAcceptBid20(hand) {
        const baseMighty = new Card(SUITS.SPADE, 'A');
        const hasMighty = hand.some(c => c.equals(baseMighty));
        const hasJoker = hand.some(c => c.isJoker);
        const suitCounts = {};
        for (const suit of Object.values(SUITS)) suitCounts[suit] = hand.filter(c => !c.isJoker && c.suit === suit).length;
        const maxSuitCount = Math.max(...Object.values(suitCounts));
        const highCards = hand.filter(c => !c.isJoker && ['A', 'K', 'Q'].includes(c.rank));
        if (hasMighty && hasJoker && maxSuitCount >= 5) return true;
        if (hasMighty && maxSuitCount >= 6 && highCards.length >= 3) return true;
        if (hasJoker && maxSuitCount >= 6 && highCards.length >= 4) return true;
        return false;
    }

    async startBidding() {
        this.gameState.phase = PHASES.BIDDING;
        this.gameState.currentTurn = this.gameState.getFirstBidder();
        this.ui.renderAll();
        await this.processBidding();
    }

    async processBidding() {
        while (!this.gameState.isBiddingComplete()) {
            const currentPlayer = this.gameState.currentTurn;
            const player = this.gameState.players[currentPlayer];
            this.ui.renderAll();
            if (player.hasPassed) { this.gameState.currentTurn = this.gameState.getNextPlayer(currentPlayer); continue; }
            if (player.isHuman) {
                this.ui.setMessage('ÎπÑÎî©ÌïòÏÑ∏Ïöî');
                this.ui.showBiddingModal();
                return;
            } else {
                await this.delay(this.settings.aiSpeed);
                const decision = this.ai.decideBid(currentPlayer);
                if (decision.action === 'bid') {
                    this.gameState.recordBid(currentPlayer, decision.value, decision.suit);
                    const sym = decision.suit === 'none' ? 'No' : SUIT_SYMBOLS[decision.suit];
                    this.ui.addAILog(currentPlayer, `${decision.value}${sym} ÎπÑÎî©`, decision.reasoning);
                } else {
                    this.gameState.recordPass(currentPlayer);
                    this.ui.addAILog(currentPlayer, 'Ìå®Ïä§', decision.reasoning);
                }
                this.gameState.currentTurn = this.gameState.getNextPlayer(currentPlayer);
            }
        }
        await this.endBidding();
    }

    handleBid(value, suit) {
        if (this.gameState.isValidBid(value, suit)) {
            this.gameState.recordBid(0, value, suit);
            this.gameState.currentTurn = this.gameState.getNextPlayer(0);
            this.processBidding();
        }
    }

    handlePass() {
        this.gameState.recordPass(0);
        this.gameState.currentTurn = this.gameState.getNextPlayer(0);
        this.processBidding();
    }

    async endBidding() {
        if (this.gameState.bidding.passedPlayers.length === GAME_CONFIG.PLAYER_COUNT) {
            this.ui.setMessage('Ï†ÑÏõê Ìå®Ïä§! Ïπ¥ÎìúÎ•º Îã§Ïãú Î∞∞Î∂ÑÌï©ÎãàÎã§...');
            await this.delay(2000);
            this.startNewGame();
            return;
        }
        if (!this.gameState.setupContract()) {
            this.ui.setMessage('Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.');
            return;
        }
        const master = this.gameState.contract.master;
        const bidValue = this.gameState.contract.bidValue;
        const giruda = this.gameState.contract.giruda;
        const girudaSymbol = this.gameState.contract.isNoGiruda ? 'No' : (giruda ? SUIT_SYMBOLS[giruda] : '-');
        this.ui.setMessage(`${this.gameState.players[master].name}Ïù¥(Í∞Ä) ${bidValue}${girudaSymbol}Î°ú Ï£ºÍ≥µ!`);
        this.ui.renderAll();
        await this.delay(1500);
        await this.startExchange();
    }

    async startExchange() {
        this.gameState.phase = PHASES.EXCHANGING;
        const master = this.gameState.contract.master;
        const masterPlayer = this.gameState.players[master];
        masterPlayer.receiveCards(this.gameState.floorCards);
        masterPlayer.sortHand(this.gameState.contract.giruda, this.gameState.contract.mighty);
        this.ui.renderAll();
        if (masterPlayer.isHuman) {
            this.ui.setMessage('Î≤ÑÎ¶¥ Ïπ¥Îìú 3Ïû•ÏùÑ ÏÑ†ÌÉùÌïòÏÑ∏Ïöî');
            this.ui.showExchangeModal();
        } else {
            await this.delay(this.settings.aiSpeed);
            const decision = this.ai.selectCardsToDiscard(master);
            this.ui.addAILog(master, 'Ïπ¥Îìú ÍµêÌôò', decision.reasoning);
            this.performExchange(master, decision.cards, { newGiruda: decision.newGiruda, isNoGiruda: decision.isNoGiruda, isSolino: decision.isSolino });
        }
    }

    handleExchange(cards, options = {}) { this.performExchange(0, cards, options); }

    performExchange(playerIndex, cards, options = {}) {
        const player = this.gameState.players[playerIndex];
        const currentBid = this.gameState.contract.bidValue;
        const isMaxBid = currentBid >= GAME_CONFIG.MAX_BID;

        let newGiruda = options.newGiruda || null;
        let isNoGiruda = options.isNoGiruda || false;
        let isSolino = options.isSolino || false;

        const messages = [];

        if (isNoGiruda && isMaxBid) {
            this.gameState.contract.giruda = null;
            this.gameState.contract.isNoGiruda = true;
            this.gameState.contract.mighty = new Card(SUITS.SPADE, 'A');
            this.gameState.contract.jokerCall = getJokerCall(null);
            messages.push('ÎÖ∏Í∏∞Î£®Îã§ ÏÑ†Ïñ∏!');
        } else if (newGiruda && newGiruda !== this.gameState.contract.giruda) {
            const oldGiruda = this.gameState.contract.giruda;
            const newBid = isMaxBid ? currentBid : Math.min(currentBid + 2, GAME_CONFIG.MAX_BID);
            this.gameState.contract.giruda = newGiruda;
            this.gameState.contract.bidValue = newBid;
            this.gameState.contract.isNoGiruda = false;
            this.gameState.contract.mighty = getMighty(newGiruda);
            this.gameState.contract.jokerCall = getJokerCall(newGiruda);
            const oldName = oldGiruda ? SUIT_NAMES[oldGiruda] : 'ÎÖ∏Í∏∞Î£®Îã§';
            if (isMaxBid) messages.push(`Í∏∞Î£®Îã§ Î≥ÄÍ≤Ω: ${oldName} ‚Üí ${SUIT_NAMES[newGiruda]}`);
            else messages.push(`Í∏∞Î£®Îã§ Î≥ÄÍ≤Ω: ${oldName} ‚Üí ${SUIT_NAMES[newGiruda]} (Í≥µÏïΩ ‚Üí ${newBid})`);
        }

        if (isSolino && isMaxBid) {
            this.gameState.contract.isSolino = true;
            messages.push('ÎÖ∏ÌîÑÎ†åÎìú(ÏÜîÎ¶¨ÎÖ∏) ÏÑ†Ïñ∏!');
        }

        if (messages.length > 0) this.ui.setMessage(messages.join(' / '));

        for (const card of cards) player.playCard(card);
        this.gameState.floorCards = cards;
        const floorPoints = cards.filter(c => c.isPointCard());
        if (floorPoints.length > 0) {
            this.gameState.players[this.gameState.contract.master].addScoreCards(floorPoints);
        }

        player.sortHand(this.gameState.contract.giruda, this.gameState.contract.mighty);
        this.ui.renderAll();
        this.startFriendDeclaration();
    }

    async startFriendDeclaration() {
        this.gameState.phase = PHASES.FRIEND_DECLARATION;
        const master = this.gameState.contract.master;
        const masterPlayer = this.gameState.players[master];

        if (this.gameState.contract.isSolino) {
            this.ui.setMessage('ÎÖ∏ÌîÑÎ†åÎìú(ÏÜîÎ¶¨ÎÖ∏)Î°ú ÏßÑÌñâÌï©ÎãàÎã§!');
            this.gameState.setFriend(null);
            this.ui.renderAll();
            await this.delay(1500);
            this.startPlaying();
            return;
        }

        if (masterPlayer.isHuman) {
            this.ui.setMessage('ÏπúÍµ¨ Ïπ¥ÎìúÎ•º ÏÑ†Ïñ∏ÌïòÏÑ∏Ïöî');
            this.ui.showFriendModal();
        } else {
            await this.delay(this.settings.aiSpeed);
            const decision = this.ai.selectFriendCard(master);
            this.ui.addAILog(master, decision.isNoFriend ? 'ÎÖ∏ÌîÑÎ†åÎìú ÏÑ†Ïñ∏' : `ÏπúÍµ¨: ${decision.card.toString()}`, decision.reasoning);
            this.gameState.setFriend(decision.isNoFriend ? null : decision.card);
            this.ui.renderAll();
            await this.delay(1000);
            this.startPlaying();
        }
    }

    handleFriendDeclare(card) {
        this.gameState.setFriend(card);
        this.ui.renderAll();
        setTimeout(() => this.startPlaying(), 500);
    }

    async startPlaying() {
        this.gameState.phase = PHASES.PLAYING;
        this.gameState.round = 1;
        this.isProcessing = false;

        if (this.settings.useSayeon && this.shouldAskSayeon()) {
            await this.askSayeon();
            return;
        }

        this.gameState.startTrick(this.gameState.contract.master);
        this.ui.renderAll();
        await this.processTrick();
    }

    shouldAskSayeon() {
        const contract = this.gameState.contract;
        const masterIndex = contract.master;
        const masterHand = this.gameState.players[masterIndex].hand;
        if (contract.isNoFriend || contract.isSolino) return false;
        if (contract.friendCard && contract.friendCard.isJoker) return false;
        if (masterHand.some(c => c.isJoker)) return false;
        if (contract.friend === null && !contract.friendCard) return false;
        return true;
    }

    async askSayeon() {
        const masterIndex = this.gameState.contract.master;
        const masterPlayer = this.gameState.players[masterIndex];
        let actualFriendIndex = this.gameState.contract.friend;
        if (actualFriendIndex === null || actualFriendIndex === undefined) {
            const friendCard = this.gameState.contract.friendCard;
            for (let i = 0; i < GAME_CONFIG.PLAYER_COUNT; i++) {
                if (i === masterIndex) continue;
                if (this.gameState.players[i].hasCard(friendCard)) { actualFriendIndex = i; break; }
            }
        }
        if (actualFriendIndex === null || actualFriendIndex === undefined) {
            this.gameState.startTrick(masterIndex);
            this.ui.renderAll();
            await this.processTrick();
            return;
        }
        const friendPlayer = this.gameState.players[actualFriendIndex];
        const friendHasJoker = friendPlayer.hand.some(c => c.isJoker);

        if (masterPlayer.isHuman) {
            this.ui.setMessage('Ï£ºÍ≥µ: "ÏÇ¨Ïó∞?"');
            this.ui.setActionButtons([
                { text: 'ÏÇ¨Ïó∞ Î¨ªÍ∏∞', primary: true, onClick: () => this.processSayeonResponse(actualFriendIndex, friendHasJoker) },
                { text: 'Í±¥ÎÑàÎõ∞Í∏∞', primary: false, onClick: () => this.skipSayeon() }
            ]);
        } else {
            this.ui.setMessage(`AI-${masterIndex}: "ÏÇ¨Ïó∞?"`);
            await this.delay(1000);
            await this.processSayeonResponse(actualFriendIndex, friendHasJoker);
        }
    }

    async processSayeonResponse(friendIndex, friendHasJoker) {
        this.ui.clearActionButtons();
        const friendPlayer = this.gameState.players[friendIndex];
        const response = friendHasJoker ? 'ÎÑåÏÇ¨' : 'ÏÇ¨Ïó∞';

        if (friendPlayer.isHuman) {
            this.ui.setMessage(`ÎãπÏã†ÏùÄ ÏπúÍµ¨ÏûÖÎãàÎã§. Ï°∞Ïª§Î•º ${friendHasJoker ? 'Í∞ÄÏßÄÍ≥† ÏûàÏäµÎãàÎã§' : 'Í∞ÄÏßÄÍ≥† ÏûàÏßÄ ÏïäÏäµÎãàÎã§'}.`);
            this.ui.setActionButtons([
                { text: friendHasJoker ? 'ÎÑåÏÇ¨ (Ï°∞Ïª§ ÏûàÏùå)' : 'ÏÇ¨Ïó∞ (Ï°∞Ïª§ ÏóÜÏùå)', primary: true, onClick: () => this.completeSayeon(response) }
            ]);
        } else {
            this.ui.setMessage(`ÏπúÍµ¨Ïùò ÏùëÎãµ: "${response}"`);
            this.gameState.sayeonResponse = response;
            await this.delay(1500);
            this.completeSayeon(response);
        }
    }

    completeSayeon(response) {
        this.ui.clearActionButtons();
        this.gameState.sayeonResponse = response;
        const masterIndex = this.gameState.contract.master;
        if (response === 'ÎÑåÏÇ¨') this.ui.setMessage('ÏπúÍµ¨Í∞Ä Ï°∞Ïª§Î•º Î≥¥Ïú†ÌïòÍ≥† ÏûàÏäµÎãàÎã§.');
        else this.ui.setMessage('ÏπúÍµ¨Í∞Ä Ï°∞Ïª§Î•º Î≥¥Ïú†ÌïòÍ≥† ÏûàÏßÄ ÏïäÏäµÎãàÎã§.');
        setTimeout(() => {
            this.gameState.startTrick(masterIndex);
            this.ui.renderAll();
            this.processTrick();
        }, 1500);
    }

    skipSayeon() {
        this.ui.clearActionButtons();
        this.gameState.sayeonResponse = null;
        const masterIndex = this.gameState.contract.master;
        this.gameState.startTrick(masterIndex);
        this.ui.renderAll();
        this.processTrick();
    }

    async processTrick() {
        if (this.gameState.trick.cards.length >= GAME_CONFIG.PLAYER_COUNT) {
            await this.endTrick();
            return;
        }
        while (this.gameState.trick.cards.length < GAME_CONFIG.PLAYER_COUNT) {
            const currentPlayer = this.gameState.currentTurn;
            const player = this.gameState.players[currentPlayer];
            this.ui.renderAll();
            if (player.isHuman) {
                this.ui.setMessage('Ïπ¥ÎìúÎ•º ÏÑ†ÌÉùÌïòÏÑ∏Ïöî');
                this.isProcessing = false;
                return;
            } else {
                await this.delay(this.settings.aiSpeed);
                const alreadyPlayed = this.gameState.trick.cards.some(p => p.player === currentPlayer);
                if (alreadyPlayed) continue;
                const decision = this.ai.selectCardToPlay(currentPlayer);
                if (!decision || !decision.card) { console.error(`AI ${currentPlayer} failed`); continue; }
                const card = player.playCard(decision.card);
                if (card) {
                    this.gameState.playCardToTrick(currentPlayer, card, decision.jokerCallSuit);
                    this.ui.addAILog(currentPlayer, `${card.toString()} Ï∂úÏ†Ñ`, decision.reasoning);
                    this.ui.renderAll();
                    this.ui.renderTrick();
                }
            }
        }
        await this.endTrick();
    }

    handleCardSelect(card) {
        if (this.isProcessing) return;
        if (this.gameState.currentTurn !== 0) return;
        if (this.gameState.trick.cards.some(p => p.player === 0)) return;
        const player = this.gameState.players[0];
        const mightyPlayedInTrick = this.gameState.trick.cards.some(p => p.card.equals(this.gameState.contract.mighty));
        const playableCards = getPlayableCards(player.hand, this.gameState.trick.leadSuit, this.gameState.round, {
            mighty: this.gameState.contract.mighty,
            jokerCalled: this.gameState.trick.jokerCalled,
            mightyPlayedInTrick
        });
        if (!playableCards.some(c => c.equals(card))) return;
        if (this.gameState.trick.cards.length === 0 && card.isJoker && this.gameState.round >= 2 && this.gameState.round <= 9) {
            this.pendingCard = card;
            this.ui.showJokerCallModal();
            return;
        }
        this.playUserCard(card, null);
    }

    handleJokerSuit(suit) {
        if (this.pendingCard) { this.playUserCard(this.pendingCard, suit); this.pendingCard = null; }
    }

    async playUserCard(card, jokerCallSuit) {
        if (this.isProcessing) return;
        const player = this.gameState.players[0];
        const playedCard = player.playCard(card);
        if (playedCard) {
            this.isProcessing = true;
            this.gameState.playCardToTrick(0, playedCard, jokerCallSuit);
            this.ui.renderAll();
            this.ui.renderTrick();
            await this.processTrick();
            this.isProcessing = false;
        }
    }

    async endTrick() {
        this.isProcessing = true;
        this.gameState.phase = PHASES.TRICK_END;
        const { winner, winningCard } = this.gameState.determineTrickWinner();
        this.ui.renderTrick();
        this.ui.setMessage(`${this.gameState.players[winner].name}Ïù¥(Í∞Ä) ${winningCard.toString()}(Ïúº)Î°ú ÏäπÎ¶¨!`);
        await this.delay(2000);
        this.gameState.endTrick();
        this.ui.renderAll();

        if (this.gameState.round >= GAME_CONFIG.TOTAL_ROUNDS) {
            this.isProcessing = false;
            await this.endGame();
        } else {
            this.gameState.round++;
            this.gameState.phase = PHASES.PLAYING;
            this.gameState.startTrick(winner);
            this.ui.clearTrick();
            this.ui.renderAll();
            await this.delay(500);
            this.isProcessing = false;
            await this.processTrick();
        }
    }

    async endGame() {
        this.gameState.phase = PHASES.GAME_END;
        const result = this.gameState.calculateFinalScores();
        for (const r of result.results) this.gameState.players[r.player].totalScore += r.change;

        this.gameHistory.push({
            gameNumber: this.gameHistory.length + 1,
            winner: result.winner, isBackrun: result.isBackrun,
            bidValue: this.gameState.contract.bidValue,
            governmentScore: this.gameState.governmentScore,
            master: this.gameState.contract.master,
            friend: this.gameState.contract.friend,
            giruda: this.gameState.contract.giruda,
            results: result.results.map(r => ({ player: r.player, change: r.change })),
            cumulativeScores: this.gameState.players.map(p => p.totalScore)
        });

        this.ui.renderAll();
        this.ui.showResultModal(result, this.gameHistory);
    }

    endSession() {
        this.showFinalSummary();
        this.gameState.reset();
        for (const player of this.gameState.players) player.totalScore = 0;
        this.isProcessing = false;
        this.pendingCard = null;
        this.ui.clearTrick();
        this.ui.clearActionButtons();
        this.gameHistory = [];
    }

    showFinalSummary() {
        let finalScores = [0, 0, 0, 0, 0];
        const playerNames = this.gameState.players.map(p => p.name);
        if (this.gameHistory.length > 0) {
            finalScores = this.gameHistory[this.gameHistory.length - 1].cumulativeScores || finalScores;
        }
        let winnerIndex = 0;
        let maxScore = finalScores[0] || 0;
        for (let i = 1; i < finalScores.length; i++) {
            if ((finalScores[i] || 0) > maxScore) { maxScore = finalScores[i] || 0; winnerIndex = i; }
        }

        let html = '<div style="text-align:center; padding:30px;">';
        html += '<h2 style="margin-bottom:20px;">üé¥ Í≤åÏûÑ Ï¢ÖÎ£å</h2>';
        html += `<p style="color:#aaa; margin-bottom:20px;">Ï¥ù ${this.gameHistory.length}Í≤åÏûÑ ÏßÑÌñâ - ÏµúÏ¢Ö ÎàÑÏ†Å Ï†êÏàò</p>`;
        html += '<div style="margin-bottom:20px;">';
        for (let i = 0; i < playerNames.length; i++) {
            const score = finalScores[i] || 0;
            const isWinner = i === winnerIndex;
            const scoreStyle = score >= 0 ? 'color:#4CAF50' : 'color:#f44336';
            const scoreText = score >= 0 ? `+${score}` : `${score}`;
            const winStyle = isWinner ? 'border:2px solid gold;background:rgba(255,215,0,0.2);' : 'background:rgba(255,255,255,0.1);';
            const crown = isWinner ? 'üëë ' : '';
            html += `<div style="padding:8px;margin:5px 0;${winStyle}border-radius:5px;">`;
            html += `<span>${crown}${playerNames[i]}</span>: <span style="${scoreStyle};font-weight:bold;">${scoreText}Ï†ê</span></div>`;
        }
        html += '</div>';
        if (this.gameHistory.length === 0) html += '<p style="color:#f44336;">ÏßÑÌñâÎêú Í≤åÏûÑÏù¥ ÏóÜÏäµÎãàÎã§.</p>';
        html += '<p style="color:#888;margin-top:20px;">ÏÉà Í≤åÏûÑÏùÑ ÏãúÏûëÌïòÎ†§Î©¥ ÌéòÏù¥ÏßÄÎ•º ÏÉàÎ°úÍ≥†Ïπ®ÌïòÏÑ∏Ïöî.</p></div>';
        document.getElementById('game-area').innerHTML = html;

        if (this.gameHistory.length > 0) {
            const isHumanWinner = winnerIndex === 0;
            const msg = isHumanWinner
                ? `üèÜ Ï∂ïÌïòÌï©ÎãàÎã§! ${playerNames[winnerIndex]}ÎãòÏù¥ ${maxScore}Ï†êÏúºÎ°ú Ïö∞ÏäπÌïòÏÖ®ÏäµÎãàÎã§! üéâ`
                : `üèÜ ${playerNames[winnerIndex]}Ïù¥(Í∞Ä) ${maxScore}Ï†êÏúºÎ°ú Ïö∞ÏäπÌñàÏäµÎãàÎã§!`;
            this.ui.setMessage(msg);
        } else {
            this.ui.setMessage('ÏßÑÌñâÎêú Í≤åÏûÑÏù¥ ÏóÜÏäµÎãàÎã§.');
        }
    }

    delay(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }
}

// ===== Í≤åÏûÑ ÏãúÏûë =====
document.addEventListener('DOMContentLoaded', () => {
    window.game = new GameController();
});
</script>
</body>
</html>